#![expect(unreachable_pub)]

use crate::install::{ClientOpt, ServerOpt};
use std::{fmt, str::FromStr};

xflags::xflags! {
    src "./src/flags.rs"

    /// Run custom build command.
    cmd xtask {
        cmd baseline {}

        cmd codegen {
            optional codegen_type: CodegenType
            optional --check
        }

        cmd dist {
            optional --client-patch-version version: String
            /// One of `x64` or `win32`. Determines the platform for the vipfmt project.
            optional --platform platform: Platform
        }

        /// Install vip-analyzer server or editor plugin.
        cmd install {
            /// Install only VS Code plugin.
            optional --client
            /// One of `code`, `code-exploration`, `code-insiders`, `codium`, or `code-oss`.
            optional --code-bin name: String

            /// Install only the language server.
            optional --server

            /// build in release with debug info set to 2.
            optional --dev-rel
        }

        /// Run all Rust tests including slow tests.
        cmd test-all {
            optional --baseline
        }

        /// Test and check everything.
        cmd verify {}
    }
}

// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct Xtask {
    pub subcommand: XtaskCmd,
}

#[derive(Debug)]
pub enum XtaskCmd {
    Baseline(Baseline),
    Codegen(Codegen),
    Dist(Dist),
    Install(Install),
    TestAll(TestAll),
    Verify(Verify),
}

#[derive(Debug)]
pub struct Baseline;

#[derive(Debug)]
pub struct Codegen {
    pub codegen_type: Option<CodegenType>,

    pub check: bool,
}

#[derive(Debug)]
pub struct Dist {
    pub client_patch_version: Option<String>,
    pub platform: Option<Platform>,
}

#[derive(Debug)]
pub struct Install {
    pub client: bool,
    pub code_bin: Option<String>,
    pub server: bool,
    pub dev_rel: bool,
}

#[derive(Debug)]
pub struct TestAll {
    pub baseline: bool,
}

#[derive(Debug)]
pub struct Verify;

impl Xtask {
    #[allow(dead_code)]
    pub fn from_env_or_exit() -> Self {
        Self::from_env_or_exit_()
    }

    #[allow(dead_code)]
    pub fn from_env() -> xflags::Result<Self> {
        Self::from_env_()
    }

    #[allow(dead_code)]
    pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
        Self::from_vec_(args)
    }
}
// generated end

#[derive(Debug, Default)]
pub enum CodegenType {
    #[default]
    All,
    Grammar,
    ParserTests,
}

impl fmt::Display for CodegenType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::All => write!(f, "all"),
            Self::Grammar => write!(f, "grammar"),
            Self::ParserTests => write!(f, "parser-tests"),
        }
    }
}

impl FromStr for CodegenType {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "all" => Ok(Self::All),
            "grammar" => Ok(Self::Grammar),
            "parser-tests" => Ok(Self::ParserTests),
            _ => Err("Invalid option".to_owned()),
        }
    }
}

impl Install {
    pub(crate) fn server(&self) -> Option<ServerOpt> {
        if self.client && !self.server {
            return None;
        }

        Some(ServerOpt { dev_rel: self.dev_rel })
    }
    pub(crate) fn client(&self) -> Option<ClientOpt> {
        if self.server && !self.client {
            return None;
        }
        Some(ClientOpt { code_bin: self.code_bin.clone() })
    }
}

#[derive(Debug, Clone, Default)]
pub enum Platform {
    #[default]
    X64,
    Win32,
}
impl Platform {
    pub fn vip_dir_suffix(&self) -> &'static str {
        match self {
            Self::X64 => "64",
            Self::Win32 => "",
        }
    }
}
impl FromStr for Platform {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "x64" => Ok(Self::X64),
            "win32" => Ok(Self::Win32),
            _ => Err("Invalid option".to_owned()),
        }
    }
}
impl fmt::Display for Platform {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::X64 => write!(f, "x64"),
            Self::Win32 => write!(f, "Win32"),
        }
    }
}

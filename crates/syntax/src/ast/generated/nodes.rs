//! Generated by `cargo xtask codegen grammar`, do not edit by hand.

use crate::{
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
    ast::{self, AstChildren, AstNode, support},
};
use std::{fmt, hash};
pub struct AccessTerm {
    pub(crate) syntax: SyntaxNode,
}
impl AccessTerm {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn ref_term(&self) -> Option<RefTerm> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
}
pub struct AliasDomain {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for AliasDomain {}
impl ast::HasType for AliasDomain {}
impl AliasDomain {}
pub struct AnyFlow {
    pub(crate) syntax: SyntaxNode,
}
impl AnyFlow {
    #[inline]
    pub fn anyflow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![anyflow])
    }
}
pub struct ApplyArgs {
    pub(crate) syntax: SyntaxNode,
}
impl ApplyArgs {
    #[inline]
    pub fn apply_args(&self) -> AstChildren<ApplyArg> {
        support::children(&self.syntax)
    }
}
pub struct ApplyTerm {
    pub(crate) syntax: SyntaxNode,
}
impl ApplyTerm {
    #[inline]
    pub fn apply_arg(&self) -> Option<ApplyArg> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn functor_args(&self) -> Option<FunctorArgs> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    #[inline]
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
}
pub struct Arity {
    pub(crate) syntax: SyntaxNode,
}
impl Arity {
    #[inline]
    pub fn arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![->])
    }
    #[inline]
    pub fn dotdotdot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![...])
    }
    #[inline]
    pub fn slash_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![/])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    #[inline]
    pub fn int_number_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![int_number])
    }
}
pub struct ArityList {
    pub(crate) syntax: SyntaxNode,
}
impl ArityList {
    #[inline]
    pub fn arities(&self) -> AstChildren<Arity> {
        support::children(&self.syntax)
    }
}
pub struct AssignStmt {
    pub(crate) syntax: SyntaxNode,
}
impl AssignStmt {
    #[inline]
    pub fn coloneq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
}
pub struct AttributeList {
    pub(crate) syntax: SyntaxNode,
}
impl AttributeList {
    #[inline]
    pub fn exprs(&self) -> Option<Exprs> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BinExpr {}
pub struct BinInclude {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStringSeq for BinInclude {}
impl BinInclude {
    #[inline]
    pub fn hashbininclude_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# bininclude])
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
pub struct BinLiteral {
    pub(crate) syntax: SyntaxNode,
}
impl BinLiteral {
    #[inline]
    pub fn exprs(&self) -> Option<Exprs> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn dollar_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![$])
    }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
pub struct BinStmt {
    pub(crate) syntax: SyntaxNode,
}
impl BinStmt {}
pub struct BitsizeDomain {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for BitsizeDomain {}
impl BitsizeDomain {
    #[inline]
    pub fn bitsize_expr(&self) -> Option<BitsizeExpr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn range_expr(&self) -> Option<RangeExpr> {
        support::child(&self.syntax)
    }
}
pub struct BitsizeExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BitsizeExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn bitsize_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![bitsize])
    }
}
pub struct CallingConvention {
    pub(crate) syntax: SyntaxNode,
}
impl CallingConvention {
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    #[inline]
    pub fn language_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![language])
    }
}
pub struct CaseArm {
    pub(crate) syntax: SyntaxNode,
}
impl CaseArm {
    #[inline]
    pub fn clause_body(&self) -> Option<ClauseBody> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn exprs(&self) -> Option<Exprs> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    #[inline]
    pub fn case_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![case])
    }
}
pub struct CatchHandler {
    pub(crate) syntax: SyntaxNode,
}
impl CatchHandler {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn catch_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![catch])
    }
    #[inline]
    pub fn do_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![do])
    }
}
pub struct ClassFactFunctor {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for ClassFactFunctor {}
impl ast::HasFormalParamList for ClassFactFunctor {}
impl ClassFactFunctor {
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn determ_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![determ])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    #[inline]
    pub fn nondeterm_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![nondeterm])
    }
    #[inline]
    pub fn single_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![single])
    }
}
pub struct ClassFactVar {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for ClassFactVar {}
impl ast::HasType for ClassFactVar {}
impl ClassFactVar {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn coloneq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    #[inline]
    pub fn erroneous_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![erroneous])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct ClassFactsSection {
    pub(crate) syntax: SyntaxNode,
}
impl ClassFactsSection {
    #[inline]
    pub fn class_facts(&self) -> AstChildren<ClassFact> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn minus_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![-])
    }
    #[inline]
    pub fn class_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![class])
    }
    #[inline]
    pub fn facts_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![facts])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct ClassItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for ClassItem {}
impl ast::HasClassSections for ClassItem {}
impl ast::HasScopeNameDecl for ClassItem {}
impl ClassItem {
    #[inline]
    pub fn end_class_item(&self) -> Option<EndClassItem> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn qualifications(&self) -> Option<OpenQualifications> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn scope_ref(&self) -> Option<ScopeRef> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn type_bounds(&self) -> Option<TypeBounds> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn class_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![class])
    }
    #[inline]
    pub fn monitor_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![monitor])
    }
}
pub struct ClassPredicate {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for ClassPredicate {}
impl ast::HasPredParams for ClassPredicate {}
impl ClassPredicate {
    #[inline]
    pub fn calling_convention(&self) -> Option<CallingConvention> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn link_name(&self) -> Option<LinkName> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn type_bounds(&self) -> Option<TypeBounds> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct ClassPredicatesSection {
    pub(crate) syntax: SyntaxNode,
}
impl ClassPredicatesSection {
    #[inline]
    pub fn class_predicates(&self) -> AstChildren<ClassPredicate> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn class_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![class])
    }
    #[inline]
    pub fn predicates_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![predicates])
    }
}
pub struct ClassPropertiesSection {
    pub(crate) syntax: SyntaxNode,
}
impl ClassPropertiesSection {
    #[inline]
    pub fn class_properties(&self) -> AstChildren<ClassProperty> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn class_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![class])
    }
    #[inline]
    pub fn properties_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![properties])
    }
}
pub struct ClassProperty {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for ClassProperty {}
impl ast::HasType for ClassProperty {}
impl ClassProperty {
    #[inline]
    pub fn flow(&self) -> Option<Flow> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct ClassSections {
    pub(crate) syntax: SyntaxNode,
}
impl ClassSections {
    #[inline]
    pub fn list(&self) -> AstChildren<RecClassSection> {
        support::children(&self.syntax)
    }
}
pub struct Clause {
    pub(crate) syntax: SyntaxNode,
}
impl Clause {
    #[inline]
    pub fn clause_body(&self) -> Option<ClauseBody> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn exprs(&self) -> Option<Exprs> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct ClauseBody {
    pub(crate) syntax: SyntaxNode,
}
impl ClauseBody {
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn colondash_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:-])
    }
}
pub struct ClausesSection {
    pub(crate) syntax: SyntaxNode,
}
impl ClausesSection {
    #[inline]
    pub fn clauses(&self) -> AstChildren<ClauseKind> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn clauses_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![clauses])
    }
}
pub struct CondClassSection {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasClassSections for CondClassSection {}
impl CondClassSection {
    #[inline]
    pub fn else_if_sections(&self) -> AstChildren<ElseIfClassSection> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn else_section(&self) -> Option<ElseClassSection> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn hashendif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# endif])
    }
    #[inline]
    pub fn hashif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# if])
    }
    #[inline]
    pub fn hashthen_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# then])
    }
}
pub struct CondImplementSection {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasImplementSections for CondImplementSection {}
impl CondImplementSection {
    #[inline]
    pub fn else_if_sections(&self) -> AstChildren<ElseIfImplementSection> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn else_section(&self) -> Option<ElseImplementSection> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn hashendif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# endif])
    }
    #[inline]
    pub fn hashif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# if])
    }
    #[inline]
    pub fn hashthen_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# then])
    }
}
pub struct CondInterfaceSection {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasInterfaceSections for CondInterfaceSection {}
impl CondInterfaceSection {
    #[inline]
    pub fn else_if_sections(&self) -> AstChildren<ElseIfInterfaceSection> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn else_section(&self) -> Option<ElseInterfaceSection> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn hashendif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# endif])
    }
    #[inline]
    pub fn hashif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# if])
    }
    #[inline]
    pub fn hashthen_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# then])
    }
}
pub struct CondItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasItems for CondItem {}
impl CondItem {
    #[inline]
    pub fn else_if_items(&self) -> AstChildren<ElseIfItem> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn else_item(&self) -> Option<ElseItem> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn item_condition(&self) -> Option<ItemCondition> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn hashendif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# endif])
    }
    #[inline]
    pub fn hashif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# if])
    }
    #[inline]
    pub fn hashthen_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# then])
    }
}
pub struct Condition {
    pub(crate) syntax: SyntaxNode,
}
impl Condition {
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
}
pub struct ConsExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ConsExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn exprs(&self) -> Option<Exprs> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
    #[inline]
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
}
pub struct Constant {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for Constant {}
impl ast::HasType for Constant {}
impl Constant {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct ConstantsSection {
    pub(crate) syntax: SyntaxNode,
}
impl ConstantsSection {
    #[inline]
    pub fn constants(&self) -> AstChildren<Constant> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn constants_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![constants])
    }
}
pub struct Constructor {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for Constructor {}
impl Constructor {
    #[inline]
    pub fn inline_params(&self) -> Option<InlineParams> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn link_name(&self) -> Option<LinkName> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn type_bounds(&self) -> Option<TypeBounds> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct ConstructorsSection {
    pub(crate) syntax: SyntaxNode,
}
impl ConstructorsSection {
    #[inline]
    pub fn constructors(&self) -> AstChildren<Constructor> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn constructors_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![constructors])
    }
}
pub struct CutStmt {
    pub(crate) syntax: SyntaxNode,
}
impl CutStmt {
    #[inline]
    pub fn excl_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![!])
    }
}
pub struct DelegateSection {
    pub(crate) syntax: SyntaxNode,
}
impl DelegateSection {
    #[inline]
    pub fn delegates(&self) -> Option<Delegates> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn delegate_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![delegate])
    }
}
pub struct Delegates {
    pub(crate) syntax: SyntaxNode,
}
impl Delegates {
    #[inline]
    pub fn delegates(&self) -> AstChildren<Delegate> {
        support::children(&self.syntax)
    }
}
pub struct DigitsDomain {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for DigitsDomain {}
impl DigitsDomain {
    #[inline]
    pub fn digits_expr(&self) -> Option<DigitsExpr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn range_expr(&self) -> Option<RangeExpr> {
        support::child(&self.syntax)
    }
}
pub struct DigitsExpr {
    pub(crate) syntax: SyntaxNode,
}
impl DigitsExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn digits_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![digits])
    }
}
pub struct Domain {
    pub(crate) syntax: SyntaxNode,
}
impl Domain {
    #[inline]
    pub fn domain_def(&self) -> Option<DomainDef> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn generics(&self) -> Option<Generics> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct DomainsSection {
    pub(crate) syntax: SyntaxNode,
}
impl DomainsSection {
    #[inline]
    pub fn domains(&self) -> AstChildren<Domain> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn domains_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![domains])
    }
}
pub struct Ellipsis {
    pub(crate) syntax: SyntaxNode,
}
impl Ellipsis {
    #[inline]
    pub fn dotdotdot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![...])
    }
}
pub struct ElseClassSection {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasClassSections for ElseClassSection {}
impl ElseClassSection {
    #[inline]
    pub fn hashelse_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# else])
    }
}
pub struct ElseIfClassSection {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasClassSections for ElseIfClassSection {}
impl ElseIfClassSection {
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn hashelseif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# elseif])
    }
    #[inline]
    pub fn hashthen_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# then])
    }
}
pub struct ElseIfImplementSection {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasImplementSections for ElseIfImplementSection {}
impl ElseIfImplementSection {
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn hashelseif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# elseif])
    }
    #[inline]
    pub fn hashthen_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# then])
    }
}
pub struct ElseIfInterfaceSection {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasInterfaceSections for ElseIfInterfaceSection {}
impl ElseIfInterfaceSection {
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn hashelseif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# elseif])
    }
    #[inline]
    pub fn hashthen_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# then])
    }
}
pub struct ElseIfItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasItems for ElseIfItem {}
impl ElseIfItem {
    #[inline]
    pub fn item_condition(&self) -> Option<ItemCondition> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn hashelseif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# elseif])
    }
    #[inline]
    pub fn hashthen_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# then])
    }
}
pub struct ElseIfTerm {
    pub(crate) syntax: SyntaxNode,
}
impl ElseIfTerm {
    #[inline]
    pub fn condition(&self) -> Option<Condition> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn elseif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![elseif])
    }
    #[inline]
    pub fn then_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![then])
    }
}
pub struct ElseImplementSection {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasImplementSections for ElseImplementSection {}
impl ElseImplementSection {
    #[inline]
    pub fn hashelse_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# else])
    }
}
pub struct ElseInterfaceSection {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasInterfaceSections for ElseInterfaceSection {}
impl ElseInterfaceSection {
    #[inline]
    pub fn hashelse_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# else])
    }
}
pub struct ElseItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasItems for ElseItem {}
impl ElseItem {
    #[inline]
    pub fn hashelse_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# else])
    }
}
pub struct ElseTerm {
    pub(crate) syntax: SyntaxNode,
}
impl ElseTerm {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn else_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![else])
    }
}
pub struct EndClassItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasScopeNameDecl for EndClassItem {}
impl EndClassItem {
    #[inline]
    pub fn class_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![class])
    }
    #[inline]
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![end])
    }
    #[inline]
    pub fn monitor_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![monitor])
    }
}
pub struct EndForeach {
    pub(crate) syntax: SyntaxNode,
}
impl EndForeach {
    #[inline]
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![end])
    }
    #[inline]
    pub fn foreach_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![foreach])
    }
}
pub struct EndIf {
    pub(crate) syntax: SyntaxNode,
}
impl EndIf {
    #[inline]
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![end])
    }
    #[inline]
    pub fn if_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![if])
    }
}
pub struct EndImplement {
    pub(crate) syntax: SyntaxNode,
}
impl EndImplement {
    #[inline]
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![end])
    }
    #[inline]
    pub fn implement_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![implement])
    }
}
pub struct EndImplementItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasScopeNameDecl for EndImplementItem {}
impl EndImplementItem {
    #[inline]
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![end])
    }
    #[inline]
    pub fn implement_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![implement])
    }
}
pub struct EndInterfaceItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasScopeNameDecl for EndInterfaceItem {}
impl EndInterfaceItem {
    #[inline]
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![end])
    }
    #[inline]
    pub fn interface_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![interface])
    }
    #[inline]
    pub fn monitor_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![monitor])
    }
}
pub struct EndMatch {
    pub(crate) syntax: SyntaxNode,
}
impl EndMatch {
    #[inline]
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![end])
    }
    #[inline]
    pub fn match_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![match])
    }
}
pub struct EndTry {
    pub(crate) syntax: SyntaxNode,
}
impl EndTry {
    #[inline]
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![end])
    }
    #[inline]
    pub fn try_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![try])
    }
}
pub struct ErrorDirective {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStringSeq for ErrorDirective {}
impl ErrorDirective {
    #[inline]
    pub fn hasherror_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# error])
    }
}
pub struct ExportItem {
    pub(crate) syntax: SyntaxNode,
}
impl ExportItem {
    #[inline]
    pub fn scope_refs(&self) -> AstChildren<ScopeRef> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn hashexport_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# export])
    }
}
pub struct Exprs {
    pub(crate) syntax: SyntaxNode,
}
impl Exprs {
    #[inline]
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
}
pub struct ExternalPredicateResolution {
    pub(crate) syntax: SyntaxNode,
}
impl ExternalPredicateResolution {
    #[inline]
    pub fn arity(&self) -> Option<Arity> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn string_or_const(&self) -> Option<StringOrConst> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn externally_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![externally])
    }
    #[inline]
    pub fn from_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![from])
    }
}
pub struct ExternallyItem {
    pub(crate) syntax: SyntaxNode,
}
impl ExternallyItem {
    #[inline]
    pub fn externally_subjects(&self) -> AstChildren<ExternallySubject> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn hashexternally_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# externally])
    }
}
pub struct ExternallySubject {
    pub(crate) syntax: SyntaxNode,
}
impl ExternallySubject {
    #[inline]
    pub fn scope_ref(&self) -> Option<ScopeRef> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn string_or_const(&self) -> Option<StringOrConst> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn hashfrom_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# from])
    }
}
pub struct FactFunctor {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for FactFunctor {}
impl ast::HasFormalParamList for FactFunctor {}
impl FactFunctor {
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn determ_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![determ])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    #[inline]
    pub fn nondeterm_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![nondeterm])
    }
    #[inline]
    pub fn single_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![single])
    }
}
pub struct FactVar {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for FactVar {}
impl ast::HasType for FactVar {}
impl FactVar {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn coloneq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    #[inline]
    pub fn erroneous_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![erroneous])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct FactsSection {
    pub(crate) syntax: SyntaxNode,
}
impl FactsSection {
    #[inline]
    pub fn facts(&self) -> AstChildren<Fact> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn minus_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![-])
    }
    #[inline]
    pub fn facts_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![facts])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct FinallyHandler {
    pub(crate) syntax: SyntaxNode,
}
impl FinallyHandler {
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn finally_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![finally])
    }
}
pub struct FindAllExpr {
    pub(crate) syntax: SyntaxNode,
}
impl FindAllExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
    #[inline]
    pub fn pipepipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![||])
    }
}
pub struct Flow {
    pub(crate) syntax: SyntaxNode,
}
impl Flow {
    #[inline]
    pub fn flow_arg_list(&self) -> Option<FlowArgList> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
pub struct FlowArgList {
    pub(crate) syntax: SyntaxNode,
}
impl FlowArgList {
    #[inline]
    pub fn flow_args(&self) -> AstChildren<FlowArg> {
        support::children(&self.syntax)
    }
}
pub struct FlowDirection {
    pub(crate) syntax: SyntaxNode,
}
impl FlowDirection {
    #[inline]
    pub fn i_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![i])
    }
    #[inline]
    pub fn o_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![o])
    }
}
pub struct FlowPatternList {
    pub(crate) syntax: SyntaxNode,
}
impl FlowPatternList {
    #[inline]
    pub fn flow_patterns(&self) -> AstChildren<FlowPattern> {
        support::children(&self.syntax)
    }
}
pub struct ForeachStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ForeachStmt {
    #[inline]
    pub fn end_foreach(&self) -> Option<EndForeach> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn iter_stmt(&self) -> Option<IterStmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn do_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![do])
    }
    #[inline]
    pub fn foreach_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![foreach])
    }
}
pub struct FormalArg {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for FormalArg {}
impl ast::HasType for FormalArg {}
impl FormalArg {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    #[inline]
    pub fn var_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![var])
    }
}
pub struct FormalArgList {
    pub(crate) syntax: SyntaxNode,
}
impl FormalArgList {
    #[inline]
    pub fn formal_args(&self) -> AstChildren<FormalArg> {
        support::children(&self.syntax)
    }
}
pub struct FormalParam {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for FormalParam {}
impl ast::HasType for FormalParam {}
impl FormalParam {
    #[inline]
    pub fn var_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![var])
    }
}
pub struct FormalParamList {
    pub(crate) syntax: SyntaxNode,
}
impl FormalParamList {
    #[inline]
    pub fn formal_params(&self) -> AstChildren<FormalParam> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    #[inline]
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
    #[inline]
    pub fn dotdotdot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![...])
    }
}
pub struct Functor {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for Functor {}
impl ast::HasType for Functor {}
impl Functor {
    #[inline]
    pub fn formal_arg_list(&self) -> Option<FormalArgList> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
pub struct FunctorArgs {
    pub(crate) syntax: SyntaxNode,
}
impl FunctorArgs {
    #[inline]
    pub fn functor_args(&self) -> AstChildren<FunctorArg> {
        support::children(&self.syntax)
    }
}
pub struct FunctorDomain {
    pub(crate) syntax: SyntaxNode,
}
impl FunctorDomain {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn functors(&self) -> AstChildren<Functor> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn align_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![align])
    }
}
pub struct FunctorFlow {
    pub(crate) syntax: SyntaxNode,
}
impl FunctorFlow {
    #[inline]
    pub fn flow(&self) -> Option<Flow> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct Generics {
    pub(crate) syntax: SyntaxNode,
}
impl Generics {
    #[inline]
    pub fn type_args(&self) -> AstChildren<TypeArg> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}
pub struct GoalItem {
    pub(crate) syntax: SyntaxNode,
}
impl GoalItem {
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn goal_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![goal])
    }
}
pub struct GuardClause {
    pub(crate) syntax: SyntaxNode,
}
impl GuardClause {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn guard_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![guard])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct IfTerm {
    pub(crate) syntax: SyntaxNode,
}
impl IfTerm {
    #[inline]
    pub fn condition(&self) -> Option<Condition> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn else_if_terms(&self) -> AstChildren<ElseIfTerm> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn else_term(&self) -> Option<ElseTerm> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn end_if(&self) -> Option<EndIf> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn if_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![if])
    }
    #[inline]
    pub fn then_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![then])
    }
}
pub struct ImplementItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for ImplementItem {}
impl ast::HasImplementSections for ImplementItem {}
impl ast::HasScopeNameDecl for ImplementItem {}
impl ImplementItem {
    #[inline]
    pub fn end_implement_item(&self) -> Option<EndImplementItem> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn qualifications(&self) -> AstChildren<ImplementQualification> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn type_bounds(&self) -> Option<TypeBounds> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn implement_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![implement])
    }
}
pub struct ImplementSections {
    pub(crate) syntax: SyntaxNode,
}
impl ImplementSections {
    #[inline]
    pub fn list(&self) -> AstChildren<RecImplementSection> {
        support::children(&self.syntax)
    }
}
pub struct InStmt {
    pub(crate) syntax: SyntaxNode,
}
impl InStmt {
    #[inline]
    pub fn in_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![in])
    }
}
pub struct IncludeItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStringSeq for IncludeItem {}
impl IncludeItem {
    #[inline]
    pub fn hashinclude_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# include])
    }
}
pub struct InheritsQualifications {
    pub(crate) syntax: SyntaxNode,
}
impl InheritsQualifications {
    #[inline]
    pub fn scope_refs(&self) -> AstChildren<ScopeRef> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn inherits_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![inherits])
    }
}
pub struct InlineParams {
    pub(crate) syntax: SyntaxNode,
}
impl InlineParams {
    #[inline]
    pub fn formal_arg_list(&self) -> Option<FormalArgList> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn pred_property_list(&self) -> Option<PredPropertyList> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn return_param(&self) -> Option<ReturnParam> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    #[inline]
    pub fn dotdotdot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![...])
    }
}
pub struct InterfaceDelegate {
    pub(crate) syntax: SyntaxNode,
}
impl InterfaceDelegate {
    #[inline]
    pub fn scope_ref(&self) -> Option<ScopeRef> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    #[inline]
    pub fn interface_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![interface])
    }
    #[inline]
    pub fn to_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![to])
    }
}
pub struct InterfaceItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for InterfaceItem {}
impl ast::HasInterfaceSections for InterfaceItem {}
impl ast::HasScopeNameDecl for InterfaceItem {}
impl InterfaceItem {
    #[inline]
    pub fn end_interface_item(&self) -> Option<EndInterfaceItem> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn qualifications(&self) -> AstChildren<InterfaceQualification> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn type_bounds(&self) -> Option<TypeBounds> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn interface_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![interface])
    }
    #[inline]
    pub fn monitor_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![monitor])
    }
}
pub struct InterfaceRef {
    pub(crate) syntax: SyntaxNode,
}
impl InterfaceRef {
    #[inline]
    pub fn scope_ref(&self) -> Option<ScopeRef> {
        support::child(&self.syntax)
    }
}
pub struct InterfaceResolution {
    pub(crate) syntax: SyntaxNode,
}
impl InterfaceResolution {
    #[inline]
    pub fn interface_ref(&self) -> Option<InterfaceRef> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn scope_ref(&self) -> Option<ScopeRef> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn from_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![from])
    }
    #[inline]
    pub fn interface_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![interface])
    }
}
pub struct InterfaceSections {
    pub(crate) syntax: SyntaxNode,
}
impl InterfaceSections {
    #[inline]
    pub fn list(&self) -> AstChildren<RecInterfaceSection> {
        support::children(&self.syntax)
    }
}
pub struct IterStmt {
    pub(crate) syntax: SyntaxNode,
}
impl IterStmt {
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
}
pub struct KeywordArg {
    pub(crate) syntax: SyntaxNode,
}
impl KeywordArg {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    #[inline]
    pub fn var_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![var])
    }
}
pub struct LambdaExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LambdaExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn exprs(&self) -> Option<Exprs> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    #[inline]
    pub fn colondash_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:-])
    }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
}
pub struct LinkName {
    pub(crate) syntax: SyntaxNode,
}
impl LinkName {
    #[inline]
    pub fn string_or_const(&self) -> Option<StringOrConst> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn as_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![as])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct ListExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ListExpr {
    #[inline]
    pub fn exprs(&self) -> Option<Exprs> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
pub struct ListFlow {
    pub(crate) syntax: SyntaxNode,
}
impl ListFlow {
    #[inline]
    pub fn flow_arg_list(&self) -> Option<FlowArgList> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn list_flow(&self) -> Option<ListFlow> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    #[inline]
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
}
pub struct ListType {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasType for ListType {}
impl ListType {
    #[inline]
    pub fn star_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![*])
    }
}
pub struct MatchStmt {
    pub(crate) syntax: SyntaxNode,
}
impl MatchStmt {
    #[inline]
    pub fn apply_args(&self) -> Option<ApplyArgs> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn case_arms(&self) -> AstChildren<CaseArm> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn end_match(&self) -> Option<EndMatch> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    #[inline]
    pub fn match_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![match])
    }
}
pub struct MessageDirective {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStringSeq for MessageDirective {}
impl MessageDirective {
    #[inline]
    pub fn hashmessage_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# message])
    }
}
pub struct Mode {
    pub(crate) syntax: SyntaxNode,
}
impl Mode {
    #[inline]
    pub fn determ_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![determ])
    }
    #[inline]
    pub fn erroneous_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![erroneous])
    }
    #[inline]
    pub fn failure_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![failure])
    }
    #[inline]
    pub fn multi_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![multi])
    }
    #[inline]
    pub fn nondeterm_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![nondeterm])
    }
    #[inline]
    pub fn procedure_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![procedure])
    }
}
pub struct Namespace {
    pub(crate) syntax: SyntaxNode,
}
impl Namespace {
    #[inline]
    pub fn namespace_path(&self) -> Option<NamespacePath> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct NamespaceItem {
    pub(crate) syntax: SyntaxNode,
}
impl NamespaceItem {
    #[inline]
    pub fn namespace(&self) -> Option<Namespace> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn namespace_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![namespace])
    }
}
pub struct NamespacePath {
    pub(crate) syntax: SyntaxNode,
}
impl NamespacePath {
    #[inline]
    pub fn path_segments(&self) -> AstChildren<PathSegment> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn backslash_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['\\'])
    }
}
pub struct NumericDomain {
    pub(crate) syntax: SyntaxNode,
}
impl NumericDomain {
    #[inline]
    pub fn bitsize_domain(&self) -> Option<BitsizeDomain> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn digits_domain(&self) -> Option<DigitsDomain> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn range_domain(&self) -> Option<RangeDomain> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn ref_term(&self) -> Option<RefTerm> {
        support::child(&self.syntax)
    }
}
pub struct NumericLiteral {
    pub(crate) syntax: SyntaxNode,
}
impl NumericLiteral {
    #[inline]
    pub fn float_number_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![float_number])
    }
    #[inline]
    pub fn int_number_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![int_number])
    }
}
pub struct ObjectExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasImplementSections for ObjectExpr {}
impl ObjectExpr {
    #[inline]
    pub fn clause_kinds(&self) -> AstChildren<ClauseKind> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn end_implement(&self) -> Option<EndImplement> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn qualifications(&self) -> AstChildren<ImplementQualification> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn scope_ref(&self) -> Option<ScopeRef> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn implement_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![implement])
    }
}
pub struct OpenQualifications {
    pub(crate) syntax: SyntaxNode,
}
impl OpenQualifications {
    #[inline]
    pub fn open_qualifications(&self) -> AstChildren<OpenQualification> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn open_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![open])
    }
}
pub struct OptionsItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStringSeq for OptionsItem {}
impl OptionsItem {
    #[inline]
    pub fn hashoptions_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# options])
    }
}
pub struct OrRequiresDirective {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStringSeq for OrRequiresDirective {}
impl OrRequiresDirective {
    #[inline]
    pub fn hashorrequires_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# orrequires])
    }
}
pub struct ParenTerm {
    pub(crate) syntax: SyntaxNode,
}
impl ParenTerm {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
pub struct PathSegment {
    pub(crate) syntax: SyntaxNode,
}
impl PathSegment {
    #[inline]
    pub fn backslash_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['\\'])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct PredProperty {
    pub(crate) syntax: SyntaxNode,
}
impl PredProperty {
    #[inline]
    pub fn flow_pattern_list(&self) -> Option<FlowPatternList> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn mode(&self) -> Option<Mode> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn suspending_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![suspending])
    }
}
pub struct PredPropertyList {
    pub(crate) syntax: SyntaxNode,
}
impl PredPropertyList {
    #[inline]
    pub fn pred_properties(&self) -> AstChildren<PredProperty> {
        support::children(&self.syntax)
    }
}
pub struct Predicate {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for Predicate {}
impl ast::HasPredParams for Predicate {}
impl Predicate {
    #[inline]
    pub fn calling_convention(&self) -> Option<CallingConvention> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn link_name(&self) -> Option<LinkName> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn type_bounds(&self) -> Option<TypeBounds> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct PredicateDelegate {
    pub(crate) syntax: SyntaxNode,
}
impl PredicateDelegate {
    #[inline]
    pub fn arity(&self) -> Option<Arity> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    #[inline]
    pub fn to_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![to])
    }
}
pub struct PredicateDomain {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for PredicateDomain {}
impl ast::HasFormalParamList for PredicateDomain {}
impl PredicateDomain {
    #[inline]
    pub fn calling_convention(&self) -> Option<CallingConvention> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn flow_pattern_list(&self) -> Option<FlowPatternList> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn mode(&self) -> Option<Mode> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn return_param(&self) -> Option<ReturnParam> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn suspending_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![suspending])
    }
}
pub struct PredicateResolution {
    pub(crate) syntax: SyntaxNode,
}
impl PredicateResolution {
    #[inline]
    pub fn arity(&self) -> Option<Arity> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn ref_term(&self) -> Option<RefTerm> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn from_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![from])
    }
}
pub struct PredicatesFromSection {
    pub(crate) syntax: SyntaxNode,
}
impl PredicatesFromSection {
    #[inline]
    pub fn arity_list(&self) -> Option<ArityList> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn scope_ref(&self) -> Option<ScopeRef> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn class_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![class])
    }
    #[inline]
    pub fn from_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![from])
    }
    #[inline]
    pub fn predicates_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![predicates])
    }
}
pub struct PredicatesSection {
    pub(crate) syntax: SyntaxNode,
}
impl PredicatesSection {
    #[inline]
    pub fn predicates(&self) -> AstChildren<Predicate> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn predicates_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![predicates])
    }
}
pub struct PrefixExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
pub struct PropertiesFromSection {
    pub(crate) syntax: SyntaxNode,
}
impl PropertiesFromSection {
    #[inline]
    pub fn arity_list(&self) -> Option<ArityList> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn scope_ref(&self) -> Option<ScopeRef> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn class_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![class])
    }
    #[inline]
    pub fn from_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![from])
    }
    #[inline]
    pub fn properties_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![properties])
    }
}
pub struct PropertiesSection {
    pub(crate) syntax: SyntaxNode,
}
impl PropertiesSection {
    #[inline]
    pub fn properties(&self) -> AstChildren<Property> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn properties_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![properties])
    }
}
pub struct Property {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for Property {}
impl ast::HasType for Property {}
impl Property {
    #[inline]
    pub fn flow(&self) -> Option<Flow> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct RangeDomain {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttributes for RangeDomain {}
impl RangeDomain {
    #[inline]
    pub fn bitsize_expr(&self) -> Option<BitsizeExpr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn digits_expr(&self) -> Option<DigitsExpr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn range_expr(&self) -> Option<RangeExpr> {
        support::child(&self.syntax)
    }
}
pub struct RangeExpr {
    pub(crate) syntax: SyntaxNode,
}
impl RangeExpr {
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
    #[inline]
    pub fn dotdot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![..])
    }
}
pub struct RefTerm {
    pub(crate) syntax: SyntaxNode,
}
impl RefTerm {
    #[inline]
    pub fn generics(&self) -> Option<Generics> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn scope_ref(&self) -> Option<ScopeRef> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn coloncolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![::])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct RelationStmt {
    pub(crate) syntax: SyntaxNode,
}
impl RelationStmt {}
pub struct RequiresDirective {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStringSeq for RequiresDirective {}
impl RequiresDirective {
    #[inline]
    pub fn or_requires_directives(&self) -> AstChildren<OrRequiresDirective> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn hashrequires_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# requires])
    }
}
pub struct Resolutions {
    pub(crate) syntax: SyntaxNode,
}
impl Resolutions {
    #[inline]
    pub fn resolutions(&self) -> AstChildren<Resolution> {
        support::children(&self.syntax)
    }
}
pub struct ResolveSection {
    pub(crate) syntax: SyntaxNode,
}
impl ResolveSection {
    #[inline]
    pub fn resolutions(&self) -> Option<Resolutions> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn resolve_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![resolve])
    }
}
pub struct ReturnParam {
    pub(crate) syntax: SyntaxNode,
}
impl ReturnParam {
    #[inline]
    pub fn type_arg(&self) -> Option<TypeArg> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![->])
    }
}
pub struct ScopeNameDecl {
    pub(crate) syntax: SyntaxNode,
}
impl ScopeNameDecl {
    #[inline]
    pub fn scope_params(&self) -> Option<ScopeParams> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct ScopeParams {
    pub(crate) syntax: SyntaxNode,
}
impl ScopeParams {
    #[inline]
    pub fn scope_types(&self) -> AstChildren<ScopeType> {
        support::children(&self.syntax)
    }
}
pub struct ScopeRef {
    pub(crate) syntax: SyntaxNode,
}
impl ScopeRef {
    #[inline]
    pub fn generics(&self) -> Option<Generics> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn namespace_path(&self) -> Option<NamespacePath> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
pub struct ScopeType {
    pub(crate) syntax: SyntaxNode,
}
impl ScopeType {
    #[inline]
    pub fn at_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![@])
    }
    #[inline]
    pub fn var_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![var])
    }
}
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasItems for SourceFile {}
impl SourceFile {}
pub struct StringInclude {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStringSeq for StringInclude {}
impl StringInclude {
    #[inline]
    pub fn hashstringinclude_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![# stringinclude])
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
pub struct StringPart {
    pub(crate) syntax: SyntaxNode,
}
impl StringPart {
    #[inline]
    pub fn string_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![string])
    }
}
pub struct StringSeq {
    pub(crate) syntax: SyntaxNode,
}
impl StringSeq {
    #[inline]
    pub fn string_parts(&self) -> AstChildren<StringPart> {
        support::children(&self.syntax)
    }
}
pub struct SupportsQualifications {
    pub(crate) syntax: SyntaxNode,
}
impl SupportsQualifications {
    #[inline]
    pub fn scope_refs(&self) -> AstChildren<ScopeRef> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn supports_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![supports])
    }
}
pub struct TryStmt {
    pub(crate) syntax: SyntaxNode,
}
impl TryStmt {
    #[inline]
    pub fn end_try(&self) -> Option<EndTry> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn try_handlers(&self) -> AstChildren<TryHandler> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn try_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![try])
    }
}
pub struct Type {
    pub(crate) syntax: SyntaxNode,
}
impl Type {
    #[inline]
    pub fn type_kind(&self) -> Option<TypeKind> {
        support::child(&self.syntax)
    }
}
pub struct TypeArg {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasType for TypeArg {}
impl TypeArg {
    #[inline]
    pub fn var_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![var])
    }
}
pub struct TypeBound {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasType for TypeBound {}
impl TypeBound {
    #[inline]
    pub fn scope_type(&self) -> Option<ScopeType> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn supports_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![supports])
    }
    #[inline]
    pub fn var_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![var])
    }
    #[inline]
    pub fn where_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![where])
    }
}
pub struct TypeBounds {
    pub(crate) syntax: SyntaxNode,
}
impl TypeBounds {
    #[inline]
    pub fn type_bounds(&self) -> AstChildren<TypeBound> {
        support::children(&self.syntax)
    }
}
pub struct VarExpr {
    pub(crate) syntax: SyntaxNode,
}
impl VarExpr {
    #[inline]
    pub fn var_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![var])
    }
}
pub struct VarType {
    pub(crate) syntax: SyntaxNode,
}
impl VarType {
    #[inline]
    pub fn var_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![var])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ApplyArg {
    KeywordArg(KeywordArg),
    Expr(Expr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AtomStmt {
    AccessTerm(AccessTerm),
    ApplyTerm(ApplyTerm),
    AssignStmt(AssignStmt),
    CutStmt(CutStmt),
    ForeachStmt(ForeachStmt),
    IfTerm(IfTerm),
    InStmt(InStmt),
    MatchStmt(MatchStmt),
    ParenTerm(ParenTerm),
    RefTerm(RefTerm),
    RelationStmt(RelationStmt),
    TryStmt(TryStmt),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ClassFact {
    ClassFactFunctor(ClassFactFunctor),
    ClassFactVar(ClassFactVar),
}
impl ast::HasAttributes for ClassFact {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ClassSection {
    ConstantsSection(ConstantsSection),
    ConstructorsSection(ConstructorsSection),
    DomainsSection(DomainsSection),
    ErrorDirective(ErrorDirective),
    MessageDirective(MessageDirective),
    PredicatesSection(PredicatesSection),
    PropertiesSection(PropertiesSection),
    RequiresDirective(RequiresDirective),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ClauseKind {
    Clause(Clause),
    GuardClause(GuardClause),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Delegate {
    InterfaceDelegate(InterfaceDelegate),
    PredicateDelegate(PredicateDelegate),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DomainDef {
    AliasDomain(AliasDomain),
    FunctorDomain(FunctorDomain),
    NumericDomain(NumericDomain),
    PredicateDomain(PredicateDomain),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    AccessTerm(AccessTerm),
    ApplyTerm(ApplyTerm),
    BinExpr(BinExpr),
    BinInclude(BinInclude),
    BinLiteral(BinLiteral),
    ConsExpr(ConsExpr),
    Ellipsis(Ellipsis),
    FindAllExpr(FindAllExpr),
    IfTerm(IfTerm),
    LambdaExpr(LambdaExpr),
    ListExpr(ListExpr),
    NumericLiteral(NumericLiteral),
    ObjectExpr(ObjectExpr),
    ParenTerm(ParenTerm),
    PrefixExpr(PrefixExpr),
    RefTerm(RefTerm),
    ScopeType(ScopeType),
    StringInclude(StringInclude),
    StringSeq(StringSeq),
    VarExpr(VarExpr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Fact {
    FactFunctor(FactFunctor),
    FactVar(FactVar),
}
impl ast::HasAttributes for Fact {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FlowArg {
    Ellipsis(Ellipsis),
    FlowDirection(FlowDirection),
    FunctorFlow(FunctorFlow),
    ListFlow(ListFlow),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FlowPattern {
    AnyFlow(AnyFlow),
    Flow(Flow),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FunctorArg {
    KeywordArg(KeywordArg),
    AtomStmt(AtomStmt),
    Expr(Expr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ImplementQualification {
    InheritsQualifications(InheritsQualifications),
    OpenQualifications(OpenQualifications),
    SupportsQualifications(SupportsQualifications),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ImplementSection {
    ClassFactsSection(ClassFactsSection),
    ClassPredicatesSection(ClassPredicatesSection),
    ClassPropertiesSection(ClassPropertiesSection),
    ClausesSection(ClausesSection),
    ConstantsSection(ConstantsSection),
    ConstructorsSection(ConstructorsSection),
    DelegateSection(DelegateSection),
    DomainsSection(DomainsSection),
    ErrorDirective(ErrorDirective),
    FactsSection(FactsSection),
    MessageDirective(MessageDirective),
    PredicatesSection(PredicatesSection),
    PropertiesSection(PropertiesSection),
    RequiresDirective(RequiresDirective),
    ResolveSection(ResolveSection),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum InterfaceQualification {
    OpenQualifications(OpenQualifications),
    SupportsQualifications(SupportsQualifications),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum InterfaceSection {
    ConstantsSection(ConstantsSection),
    DomainsSection(DomainsSection),
    ErrorDirective(ErrorDirective),
    MessageDirective(MessageDirective),
    PredicatesFromSection(PredicatesFromSection),
    PredicatesSection(PredicatesSection),
    PropertiesFromSection(PropertiesFromSection),
    PropertiesSection(PropertiesSection),
    RequiresDirective(RequiresDirective),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Item {
    ClassItem(ClassItem),
    ErrorDirective(ErrorDirective),
    ExportItem(ExportItem),
    ExternallyItem(ExternallyItem),
    GoalItem(GoalItem),
    ImplementItem(ImplementItem),
    IncludeItem(IncludeItem),
    InterfaceItem(InterfaceItem),
    MessageDirective(MessageDirective),
    NamespaceItem(NamespaceItem),
    OptionsItem(OptionsItem),
    RequiresDirective(RequiresDirective),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ItemCondition {
    ExportItem(ExportItem),
    Stmt(Stmt),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum OpenQualification {
    NamespacePath(NamespacePath),
    ScopeRef(ScopeRef),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PredParams {
    InlineParams(InlineParams),
    RefTerm(RefTerm),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RecClassSection {
    CondClassSection(CondClassSection),
    ClassSection(ClassSection),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RecImplementSection {
    CondImplementSection(CondImplementSection),
    ImplementSection(ImplementSection),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RecInterfaceSection {
    CondInterfaceSection(CondInterfaceSection),
    InterfaceSection(InterfaceSection),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RecItem {
    CondItem(CondItem),
    Item(Item),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Resolution {
    ExternalPredicateResolution(ExternalPredicateResolution),
    InterfaceResolution(InterfaceResolution),
    PredicateResolution(PredicateResolution),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    BinStmt(BinStmt),
    AtomStmt(AtomStmt),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum StringOrConst {
    RefTerm(RefTerm),
    StringSeq(StringSeq),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TryHandler {
    CatchHandler(CatchHandler),
    FinallyHandler(FinallyHandler),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TypeKind {
    ListType(ListType),
    RefTerm(RefTerm),
    ScopeType(ScopeType),
    VarType(VarType),
}
pub struct AnyHasAttributes {
    pub(crate) syntax: SyntaxNode,
}
impl AnyHasAttributes {
    #[inline]
    pub fn new<T: ast::HasAttributes>(node: T) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax().clone() }
    }
}
pub struct AnyHasClassSections {
    pub(crate) syntax: SyntaxNode,
}
impl AnyHasClassSections {
    #[inline]
    pub fn new<T: ast::HasClassSections>(node: T) -> AnyHasClassSections {
        AnyHasClassSections { syntax: node.syntax().clone() }
    }
}
pub struct AnyHasFormalParamList {
    pub(crate) syntax: SyntaxNode,
}
impl AnyHasFormalParamList {
    #[inline]
    pub fn new<T: ast::HasFormalParamList>(node: T) -> AnyHasFormalParamList {
        AnyHasFormalParamList { syntax: node.syntax().clone() }
    }
}
pub struct AnyHasImplementSections {
    pub(crate) syntax: SyntaxNode,
}
impl AnyHasImplementSections {
    #[inline]
    pub fn new<T: ast::HasImplementSections>(node: T) -> AnyHasImplementSections {
        AnyHasImplementSections { syntax: node.syntax().clone() }
    }
}
pub struct AnyHasInterfaceSections {
    pub(crate) syntax: SyntaxNode,
}
impl AnyHasInterfaceSections {
    #[inline]
    pub fn new<T: ast::HasInterfaceSections>(node: T) -> AnyHasInterfaceSections {
        AnyHasInterfaceSections { syntax: node.syntax().clone() }
    }
}
pub struct AnyHasItems {
    pub(crate) syntax: SyntaxNode,
}
impl AnyHasItems {
    #[inline]
    pub fn new<T: ast::HasItems>(node: T) -> AnyHasItems {
        AnyHasItems { syntax: node.syntax().clone() }
    }
}
pub struct AnyHasPredParams {
    pub(crate) syntax: SyntaxNode,
}
impl AnyHasPredParams {
    #[inline]
    pub fn new<T: ast::HasPredParams>(node: T) -> AnyHasPredParams {
        AnyHasPredParams { syntax: node.syntax().clone() }
    }
}
pub struct AnyHasScopeNameDecl {
    pub(crate) syntax: SyntaxNode,
}
impl AnyHasScopeNameDecl {
    #[inline]
    pub fn new<T: ast::HasScopeNameDecl>(node: T) -> AnyHasScopeNameDecl {
        AnyHasScopeNameDecl { syntax: node.syntax().clone() }
    }
}
pub struct AnyHasStringSeq {
    pub(crate) syntax: SyntaxNode,
}
impl AnyHasStringSeq {
    #[inline]
    pub fn new<T: ast::HasStringSeq>(node: T) -> AnyHasStringSeq {
        AnyHasStringSeq { syntax: node.syntax().clone() }
    }
}
pub struct AnyHasType {
    pub(crate) syntax: SyntaxNode,
}
impl AnyHasType {
    #[inline]
    pub fn new<T: ast::HasType>(node: T) -> AnyHasType {
        AnyHasType { syntax: node.syntax().clone() }
    }
}
impl AstNode for AccessTerm {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ACCESS_TERM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AccessTerm {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AccessTerm {}
impl PartialEq for AccessTerm {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AccessTerm {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AccessTerm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AccessTerm").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for AliasDomain {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ALIAS_DOMAIN
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AliasDomain {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AliasDomain {}
impl PartialEq for AliasDomain {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AliasDomain {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AliasDomain {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AliasDomain").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for AnyFlow {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ANY_FLOW
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AnyFlow {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AnyFlow {}
impl PartialEq for AnyFlow {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AnyFlow {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AnyFlow {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AnyFlow").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ApplyArgs {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == APPLY_ARGS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ApplyArgs {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ApplyArgs {}
impl PartialEq for ApplyArgs {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ApplyArgs {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ApplyArgs {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ApplyArgs").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ApplyTerm {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == APPLY_TERM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ApplyTerm {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ApplyTerm {}
impl PartialEq for ApplyTerm {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ApplyTerm {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ApplyTerm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ApplyTerm").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Arity {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARITY
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Arity {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Arity {}
impl PartialEq for Arity {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Arity {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Arity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Arity").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ArityList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARITY_LIST
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ArityList {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ArityList {}
impl PartialEq for ArityList {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ArityList {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ArityList {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ArityList").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for AssignStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSIGN_STMT
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AssignStmt {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AssignStmt {}
impl PartialEq for AssignStmt {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AssignStmt {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AssignStmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AssignStmt").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for AttributeList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ATTRIBUTE_LIST
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AttributeList {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AttributeList {}
impl PartialEq for AttributeList {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AttributeList {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AttributeList {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AttributeList").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for BinExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BIN_EXPR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for BinExpr {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for BinExpr {}
impl PartialEq for BinExpr {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for BinExpr {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for BinExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("BinExpr").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for BinInclude {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BIN_INCLUDE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for BinInclude {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for BinInclude {}
impl PartialEq for BinInclude {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for BinInclude {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for BinInclude {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("BinInclude").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for BinLiteral {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BIN_LITERAL
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for BinLiteral {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for BinLiteral {}
impl PartialEq for BinLiteral {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for BinLiteral {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for BinLiteral {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("BinLiteral").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for BinStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BIN_STMT
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for BinStmt {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for BinStmt {}
impl PartialEq for BinStmt {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for BinStmt {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for BinStmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("BinStmt").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for BitsizeDomain {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BITSIZE_DOMAIN
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for BitsizeDomain {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for BitsizeDomain {}
impl PartialEq for BitsizeDomain {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for BitsizeDomain {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for BitsizeDomain {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("BitsizeDomain").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for BitsizeExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BITSIZE_EXPR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for BitsizeExpr {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for BitsizeExpr {}
impl PartialEq for BitsizeExpr {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for BitsizeExpr {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for BitsizeExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("BitsizeExpr").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for CallingConvention {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CALLING_CONVENTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for CallingConvention {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for CallingConvention {}
impl PartialEq for CallingConvention {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for CallingConvention {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for CallingConvention {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("CallingConvention").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for CaseArm {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CASE_ARM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for CaseArm {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for CaseArm {}
impl PartialEq for CaseArm {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for CaseArm {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for CaseArm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("CaseArm").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for CatchHandler {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CATCH_HANDLER
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for CatchHandler {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for CatchHandler {}
impl PartialEq for CatchHandler {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for CatchHandler {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for CatchHandler {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("CatchHandler").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ClassFactFunctor {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLASS_FACT_FUNCTOR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ClassFactFunctor {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ClassFactFunctor {}
impl PartialEq for ClassFactFunctor {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ClassFactFunctor {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ClassFactFunctor {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ClassFactFunctor").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ClassFactVar {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLASS_FACT_VAR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ClassFactVar {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ClassFactVar {}
impl PartialEq for ClassFactVar {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ClassFactVar {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ClassFactVar {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ClassFactVar").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ClassFactsSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLASS_FACTS_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ClassFactsSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ClassFactsSection {}
impl PartialEq for ClassFactsSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ClassFactsSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ClassFactsSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ClassFactsSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ClassItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLASS_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ClassItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ClassItem {}
impl PartialEq for ClassItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ClassItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ClassItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ClassItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ClassPredicate {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLASS_PREDICATE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ClassPredicate {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ClassPredicate {}
impl PartialEq for ClassPredicate {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ClassPredicate {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ClassPredicate {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ClassPredicate").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ClassPredicatesSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLASS_PREDICATES_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ClassPredicatesSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ClassPredicatesSection {}
impl PartialEq for ClassPredicatesSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ClassPredicatesSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ClassPredicatesSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ClassPredicatesSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ClassPropertiesSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLASS_PROPERTIES_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ClassPropertiesSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ClassPropertiesSection {}
impl PartialEq for ClassPropertiesSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ClassPropertiesSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ClassPropertiesSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ClassPropertiesSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ClassProperty {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLASS_PROPERTY
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ClassProperty {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ClassProperty {}
impl PartialEq for ClassProperty {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ClassProperty {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ClassProperty {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ClassProperty").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ClassSections {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLASS_SECTIONS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ClassSections {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ClassSections {}
impl PartialEq for ClassSections {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ClassSections {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ClassSections {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ClassSections").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Clause {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLAUSE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Clause {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Clause {}
impl PartialEq for Clause {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Clause {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Clause {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Clause").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ClauseBody {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLAUSE_BODY
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ClauseBody {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ClauseBody {}
impl PartialEq for ClauseBody {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ClauseBody {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ClauseBody {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ClauseBody").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ClausesSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLAUSES_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ClausesSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ClausesSection {}
impl PartialEq for ClausesSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ClausesSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ClausesSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ClausesSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for CondClassSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COND_CLASS_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for CondClassSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for CondClassSection {}
impl PartialEq for CondClassSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for CondClassSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for CondClassSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("CondClassSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for CondImplementSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COND_IMPLEMENT_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for CondImplementSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for CondImplementSection {}
impl PartialEq for CondImplementSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for CondImplementSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for CondImplementSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("CondImplementSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for CondInterfaceSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COND_INTERFACE_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for CondInterfaceSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for CondInterfaceSection {}
impl PartialEq for CondInterfaceSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for CondInterfaceSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for CondInterfaceSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("CondInterfaceSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for CondItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COND_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for CondItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for CondItem {}
impl PartialEq for CondItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for CondItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for CondItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("CondItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Condition {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONDITION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Condition {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Condition {}
impl PartialEq for Condition {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Condition {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Condition {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Condition").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ConsExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONS_EXPR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ConsExpr {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ConsExpr {}
impl PartialEq for ConsExpr {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ConsExpr {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ConsExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ConsExpr").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Constant {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONSTANT
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Constant {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Constant {}
impl PartialEq for Constant {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Constant {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Constant {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Constant").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ConstantsSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONSTANTS_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ConstantsSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ConstantsSection {}
impl PartialEq for ConstantsSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ConstantsSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ConstantsSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ConstantsSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Constructor {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONSTRUCTOR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Constructor {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Constructor {}
impl PartialEq for Constructor {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Constructor {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Constructor {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Constructor").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ConstructorsSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONSTRUCTORS_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ConstructorsSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ConstructorsSection {}
impl PartialEq for ConstructorsSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ConstructorsSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ConstructorsSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ConstructorsSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for CutStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CUT_STMT
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for CutStmt {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for CutStmt {}
impl PartialEq for CutStmt {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for CutStmt {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for CutStmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("CutStmt").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for DelegateSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DELEGATE_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for DelegateSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for DelegateSection {}
impl PartialEq for DelegateSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for DelegateSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for DelegateSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("DelegateSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Delegates {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DELEGATES
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Delegates {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Delegates {}
impl PartialEq for Delegates {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Delegates {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Delegates {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Delegates").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for DigitsDomain {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DIGITS_DOMAIN
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for DigitsDomain {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for DigitsDomain {}
impl PartialEq for DigitsDomain {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for DigitsDomain {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for DigitsDomain {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("DigitsDomain").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for DigitsExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DIGITS_EXPR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for DigitsExpr {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for DigitsExpr {}
impl PartialEq for DigitsExpr {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for DigitsExpr {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for DigitsExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("DigitsExpr").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Domain {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DOMAIN
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Domain {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Domain {}
impl PartialEq for Domain {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Domain {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Domain {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Domain").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for DomainsSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DOMAINS_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for DomainsSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for DomainsSection {}
impl PartialEq for DomainsSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for DomainsSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for DomainsSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("DomainsSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Ellipsis {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELLIPSIS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Ellipsis {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Ellipsis {}
impl PartialEq for Ellipsis {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Ellipsis {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Ellipsis {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Ellipsis").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ElseClassSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELSE_CLASS_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ElseClassSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ElseClassSection {}
impl PartialEq for ElseClassSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ElseClassSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ElseClassSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ElseClassSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ElseIfClassSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELSE_IF_CLASS_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ElseIfClassSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ElseIfClassSection {}
impl PartialEq for ElseIfClassSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ElseIfClassSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ElseIfClassSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ElseIfClassSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ElseIfImplementSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELSE_IF_IMPLEMENT_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ElseIfImplementSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ElseIfImplementSection {}
impl PartialEq for ElseIfImplementSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ElseIfImplementSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ElseIfImplementSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ElseIfImplementSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ElseIfInterfaceSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELSE_IF_INTERFACE_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ElseIfInterfaceSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ElseIfInterfaceSection {}
impl PartialEq for ElseIfInterfaceSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ElseIfInterfaceSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ElseIfInterfaceSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ElseIfInterfaceSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ElseIfItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELSE_IF_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ElseIfItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ElseIfItem {}
impl PartialEq for ElseIfItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ElseIfItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ElseIfItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ElseIfItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ElseIfTerm {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELSE_IF_TERM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ElseIfTerm {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ElseIfTerm {}
impl PartialEq for ElseIfTerm {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ElseIfTerm {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ElseIfTerm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ElseIfTerm").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ElseImplementSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELSE_IMPLEMENT_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ElseImplementSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ElseImplementSection {}
impl PartialEq for ElseImplementSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ElseImplementSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ElseImplementSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ElseImplementSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ElseInterfaceSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELSE_INTERFACE_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ElseInterfaceSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ElseInterfaceSection {}
impl PartialEq for ElseInterfaceSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ElseInterfaceSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ElseInterfaceSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ElseInterfaceSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ElseItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELSE_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ElseItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ElseItem {}
impl PartialEq for ElseItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ElseItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ElseItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ElseItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ElseTerm {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELSE_TERM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ElseTerm {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ElseTerm {}
impl PartialEq for ElseTerm {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ElseTerm {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ElseTerm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ElseTerm").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for EndClassItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == END_CLASS_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for EndClassItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for EndClassItem {}
impl PartialEq for EndClassItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for EndClassItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for EndClassItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("EndClassItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for EndForeach {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == END_FOREACH
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for EndForeach {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for EndForeach {}
impl PartialEq for EndForeach {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for EndForeach {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for EndForeach {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("EndForeach").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for EndIf {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == END_IF
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for EndIf {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for EndIf {}
impl PartialEq for EndIf {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for EndIf {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for EndIf {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("EndIf").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for EndImplement {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == END_IMPLEMENT
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for EndImplement {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for EndImplement {}
impl PartialEq for EndImplement {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for EndImplement {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for EndImplement {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("EndImplement").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for EndImplementItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == END_IMPLEMENT_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for EndImplementItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for EndImplementItem {}
impl PartialEq for EndImplementItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for EndImplementItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for EndImplementItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("EndImplementItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for EndInterfaceItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == END_INTERFACE_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for EndInterfaceItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for EndInterfaceItem {}
impl PartialEq for EndInterfaceItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for EndInterfaceItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for EndInterfaceItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("EndInterfaceItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for EndMatch {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == END_MATCH
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for EndMatch {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for EndMatch {}
impl PartialEq for EndMatch {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for EndMatch {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for EndMatch {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("EndMatch").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for EndTry {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == END_TRY
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for EndTry {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for EndTry {}
impl PartialEq for EndTry {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for EndTry {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for EndTry {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("EndTry").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ErrorDirective {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ERROR_DIRECTIVE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ErrorDirective {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ErrorDirective {}
impl PartialEq for ErrorDirective {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ErrorDirective {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ErrorDirective {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ErrorDirective").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ExportItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPORT_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ExportItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ExportItem {}
impl PartialEq for ExportItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ExportItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ExportItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ExportItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Exprs {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPRS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Exprs {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Exprs {}
impl PartialEq for Exprs {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Exprs {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Exprs {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Exprs").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ExternalPredicateResolution {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXTERNAL_PREDICATE_RESOLUTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ExternalPredicateResolution {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ExternalPredicateResolution {}
impl PartialEq for ExternalPredicateResolution {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ExternalPredicateResolution {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ExternalPredicateResolution {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ExternalPredicateResolution").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ExternallyItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXTERNALLY_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ExternallyItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ExternallyItem {}
impl PartialEq for ExternallyItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ExternallyItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ExternallyItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ExternallyItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ExternallySubject {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXTERNALLY_SUBJECT
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ExternallySubject {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ExternallySubject {}
impl PartialEq for ExternallySubject {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ExternallySubject {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ExternallySubject {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ExternallySubject").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FactFunctor {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FACT_FUNCTOR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FactFunctor {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FactFunctor {}
impl PartialEq for FactFunctor {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FactFunctor {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FactFunctor {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FactFunctor").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FactVar {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FACT_VAR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FactVar {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FactVar {}
impl PartialEq for FactVar {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FactVar {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FactVar {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FactVar").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FactsSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FACTS_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FactsSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FactsSection {}
impl PartialEq for FactsSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FactsSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FactsSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FactsSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FinallyHandler {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FINALLY_HANDLER
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FinallyHandler {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FinallyHandler {}
impl PartialEq for FinallyHandler {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FinallyHandler {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FinallyHandler {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FinallyHandler").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FindAllExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FIND_ALL_EXPR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FindAllExpr {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FindAllExpr {}
impl PartialEq for FindAllExpr {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FindAllExpr {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FindAllExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FindAllExpr").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Flow {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FLOW
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Flow {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Flow {}
impl PartialEq for Flow {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Flow {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Flow {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Flow").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FlowArgList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FLOW_ARG_LIST
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FlowArgList {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FlowArgList {}
impl PartialEq for FlowArgList {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FlowArgList {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FlowArgList {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FlowArgList").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FlowDirection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FLOW_DIRECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FlowDirection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FlowDirection {}
impl PartialEq for FlowDirection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FlowDirection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FlowDirection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FlowDirection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FlowPatternList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FLOW_PATTERN_LIST
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FlowPatternList {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FlowPatternList {}
impl PartialEq for FlowPatternList {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FlowPatternList {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FlowPatternList {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FlowPatternList").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ForeachStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FOREACH_STMT
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ForeachStmt {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ForeachStmt {}
impl PartialEq for ForeachStmt {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ForeachStmt {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ForeachStmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ForeachStmt").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FormalArg {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FORMAL_ARG
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FormalArg {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FormalArg {}
impl PartialEq for FormalArg {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FormalArg {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FormalArg {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FormalArg").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FormalArgList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FORMAL_ARG_LIST
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FormalArgList {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FormalArgList {}
impl PartialEq for FormalArgList {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FormalArgList {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FormalArgList {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FormalArgList").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FormalParam {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FORMAL_PARAM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FormalParam {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FormalParam {}
impl PartialEq for FormalParam {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FormalParam {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FormalParam {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FormalParam").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FormalParamList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FORMAL_PARAM_LIST
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FormalParamList {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FormalParamList {}
impl PartialEq for FormalParamList {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FormalParamList {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FormalParamList {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FormalParamList").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Functor {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNCTOR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Functor {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Functor {}
impl PartialEq for Functor {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Functor {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Functor {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Functor").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FunctorArgs {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNCTOR_ARGS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FunctorArgs {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FunctorArgs {}
impl PartialEq for FunctorArgs {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FunctorArgs {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FunctorArgs {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FunctorArgs").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FunctorDomain {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNCTOR_DOMAIN
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FunctorDomain {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FunctorDomain {}
impl PartialEq for FunctorDomain {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FunctorDomain {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FunctorDomain {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FunctorDomain").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for FunctorFlow {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNCTOR_FLOW
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for FunctorFlow {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for FunctorFlow {}
impl PartialEq for FunctorFlow {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for FunctorFlow {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for FunctorFlow {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FunctorFlow").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Generics {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GENERICS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Generics {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Generics {}
impl PartialEq for Generics {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Generics {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Generics {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Generics").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for GoalItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GOAL_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for GoalItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for GoalItem {}
impl PartialEq for GoalItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for GoalItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for GoalItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("GoalItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for GuardClause {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GUARD_CLAUSE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for GuardClause {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for GuardClause {}
impl PartialEq for GuardClause {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for GuardClause {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for GuardClause {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("GuardClause").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for IfTerm {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IF_TERM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for IfTerm {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for IfTerm {}
impl PartialEq for IfTerm {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for IfTerm {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for IfTerm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("IfTerm").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ImplementItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IMPLEMENT_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ImplementItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ImplementItem {}
impl PartialEq for ImplementItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ImplementItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ImplementItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ImplementItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ImplementSections {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IMPLEMENT_SECTIONS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ImplementSections {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ImplementSections {}
impl PartialEq for ImplementSections {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ImplementSections {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ImplementSections {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ImplementSections").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for InStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IN_STMT
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for InStmt {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for InStmt {}
impl PartialEq for InStmt {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for InStmt {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for InStmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("InStmt").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for IncludeItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INCLUDE_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for IncludeItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for IncludeItem {}
impl PartialEq for IncludeItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for IncludeItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for IncludeItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("IncludeItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for InheritsQualifications {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INHERITS_QUALIFICATIONS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for InheritsQualifications {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for InheritsQualifications {}
impl PartialEq for InheritsQualifications {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for InheritsQualifications {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for InheritsQualifications {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("InheritsQualifications").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for InlineParams {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INLINE_PARAMS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for InlineParams {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for InlineParams {}
impl PartialEq for InlineParams {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for InlineParams {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for InlineParams {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("InlineParams").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for InterfaceDelegate {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INTERFACE_DELEGATE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for InterfaceDelegate {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for InterfaceDelegate {}
impl PartialEq for InterfaceDelegate {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for InterfaceDelegate {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for InterfaceDelegate {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("InterfaceDelegate").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for InterfaceItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INTERFACE_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for InterfaceItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for InterfaceItem {}
impl PartialEq for InterfaceItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for InterfaceItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for InterfaceItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("InterfaceItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for InterfaceRef {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INTERFACE_REF
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for InterfaceRef {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for InterfaceRef {}
impl PartialEq for InterfaceRef {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for InterfaceRef {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for InterfaceRef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("InterfaceRef").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for InterfaceResolution {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INTERFACE_RESOLUTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for InterfaceResolution {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for InterfaceResolution {}
impl PartialEq for InterfaceResolution {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for InterfaceResolution {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for InterfaceResolution {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("InterfaceResolution").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for InterfaceSections {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INTERFACE_SECTIONS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for InterfaceSections {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for InterfaceSections {}
impl PartialEq for InterfaceSections {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for InterfaceSections {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for InterfaceSections {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("InterfaceSections").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for IterStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ITER_STMT
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for IterStmt {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for IterStmt {}
impl PartialEq for IterStmt {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for IterStmt {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for IterStmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("IterStmt").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for KeywordArg {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == KEYWORD_ARG
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for KeywordArg {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for KeywordArg {}
impl PartialEq for KeywordArg {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for KeywordArg {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for KeywordArg {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("KeywordArg").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for LambdaExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LAMBDA_EXPR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for LambdaExpr {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for LambdaExpr {}
impl PartialEq for LambdaExpr {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for LambdaExpr {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for LambdaExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("LambdaExpr").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for LinkName {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LINK_NAME
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for LinkName {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for LinkName {}
impl PartialEq for LinkName {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for LinkName {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for LinkName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("LinkName").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ListExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_EXPR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ListExpr {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ListExpr {}
impl PartialEq for ListExpr {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ListExpr {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ListExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ListExpr").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ListFlow {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_FLOW
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ListFlow {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ListFlow {}
impl PartialEq for ListFlow {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ListFlow {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ListFlow {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ListFlow").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ListType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_TYPE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ListType {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ListType {}
impl PartialEq for ListType {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ListType {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ListType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ListType").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for MatchStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MATCH_STMT
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for MatchStmt {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for MatchStmt {}
impl PartialEq for MatchStmt {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for MatchStmt {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for MatchStmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MatchStmt").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for MessageDirective {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MESSAGE_DIRECTIVE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for MessageDirective {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for MessageDirective {}
impl PartialEq for MessageDirective {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for MessageDirective {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for MessageDirective {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MessageDirective").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Mode {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MODE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Mode {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Mode {}
impl PartialEq for Mode {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Mode {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Mode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Mode").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Namespace {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAMESPACE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Namespace {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Namespace {}
impl PartialEq for Namespace {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Namespace {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Namespace {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Namespace").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for NamespaceItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAMESPACE_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for NamespaceItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for NamespaceItem {}
impl PartialEq for NamespaceItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for NamespaceItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for NamespaceItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("NamespaceItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for NamespacePath {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAMESPACE_PATH
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for NamespacePath {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for NamespacePath {}
impl PartialEq for NamespacePath {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for NamespacePath {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for NamespacePath {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("NamespacePath").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for NumericDomain {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NUMERIC_DOMAIN
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for NumericDomain {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for NumericDomain {}
impl PartialEq for NumericDomain {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for NumericDomain {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for NumericDomain {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("NumericDomain").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for NumericLiteral {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NUMERIC_LITERAL
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for NumericLiteral {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for NumericLiteral {}
impl PartialEq for NumericLiteral {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for NumericLiteral {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for NumericLiteral {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("NumericLiteral").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ObjectExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OBJECT_EXPR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ObjectExpr {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ObjectExpr {}
impl PartialEq for ObjectExpr {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ObjectExpr {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ObjectExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ObjectExpr").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for OpenQualifications {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OPEN_QUALIFICATIONS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for OpenQualifications {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for OpenQualifications {}
impl PartialEq for OpenQualifications {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for OpenQualifications {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for OpenQualifications {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("OpenQualifications").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for OptionsItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OPTIONS_ITEM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for OptionsItem {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for OptionsItem {}
impl PartialEq for OptionsItem {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for OptionsItem {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for OptionsItem {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("OptionsItem").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for OrRequiresDirective {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OR_REQUIRES_DIRECTIVE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for OrRequiresDirective {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for OrRequiresDirective {}
impl PartialEq for OrRequiresDirective {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for OrRequiresDirective {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for OrRequiresDirective {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("OrRequiresDirective").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ParenTerm {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PAREN_TERM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ParenTerm {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ParenTerm {}
impl PartialEq for ParenTerm {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ParenTerm {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ParenTerm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ParenTerm").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for PathSegment {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PATH_SEGMENT
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for PathSegment {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for PathSegment {}
impl PartialEq for PathSegment {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for PathSegment {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for PathSegment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PathSegment").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for PredProperty {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PRED_PROPERTY
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for PredProperty {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for PredProperty {}
impl PartialEq for PredProperty {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for PredProperty {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for PredProperty {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PredProperty").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for PredPropertyList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PRED_PROPERTY_LIST
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for PredPropertyList {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for PredPropertyList {}
impl PartialEq for PredPropertyList {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for PredPropertyList {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for PredPropertyList {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PredPropertyList").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Predicate {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREDICATE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Predicate {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Predicate {}
impl PartialEq for Predicate {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Predicate {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Predicate {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Predicate").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for PredicateDelegate {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREDICATE_DELEGATE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for PredicateDelegate {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for PredicateDelegate {}
impl PartialEq for PredicateDelegate {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for PredicateDelegate {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for PredicateDelegate {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PredicateDelegate").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for PredicateDomain {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREDICATE_DOMAIN
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for PredicateDomain {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for PredicateDomain {}
impl PartialEq for PredicateDomain {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for PredicateDomain {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for PredicateDomain {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PredicateDomain").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for PredicateResolution {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREDICATE_RESOLUTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for PredicateResolution {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for PredicateResolution {}
impl PartialEq for PredicateResolution {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for PredicateResolution {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for PredicateResolution {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PredicateResolution").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for PredicatesFromSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREDICATES_FROM_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for PredicatesFromSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for PredicatesFromSection {}
impl PartialEq for PredicatesFromSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for PredicatesFromSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for PredicatesFromSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PredicatesFromSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for PredicatesSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREDICATES_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for PredicatesSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for PredicatesSection {}
impl PartialEq for PredicatesSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for PredicatesSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for PredicatesSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PredicatesSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for PrefixExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_EXPR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for PrefixExpr {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for PrefixExpr {}
impl PartialEq for PrefixExpr {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for PrefixExpr {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for PrefixExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PrefixExpr").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for PropertiesFromSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PROPERTIES_FROM_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for PropertiesFromSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for PropertiesFromSection {}
impl PartialEq for PropertiesFromSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for PropertiesFromSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for PropertiesFromSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PropertiesFromSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for PropertiesSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PROPERTIES_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for PropertiesSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for PropertiesSection {}
impl PartialEq for PropertiesSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for PropertiesSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for PropertiesSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PropertiesSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Property {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PROPERTY
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Property {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Property {}
impl PartialEq for Property {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Property {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Property {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Property").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for RangeDomain {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RANGE_DOMAIN
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for RangeDomain {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for RangeDomain {}
impl PartialEq for RangeDomain {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for RangeDomain {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for RangeDomain {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RangeDomain").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for RangeExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RANGE_EXPR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for RangeExpr {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for RangeExpr {}
impl PartialEq for RangeExpr {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for RangeExpr {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for RangeExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RangeExpr").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for RefTerm {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == REF_TERM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for RefTerm {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for RefTerm {}
impl PartialEq for RefTerm {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for RefTerm {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for RefTerm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RefTerm").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for RelationStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RELATION_STMT
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for RelationStmt {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for RelationStmt {}
impl PartialEq for RelationStmt {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for RelationStmt {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for RelationStmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RelationStmt").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for RequiresDirective {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == REQUIRES_DIRECTIVE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for RequiresDirective {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for RequiresDirective {}
impl PartialEq for RequiresDirective {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for RequiresDirective {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for RequiresDirective {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RequiresDirective").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Resolutions {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RESOLUTIONS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Resolutions {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Resolutions {}
impl PartialEq for Resolutions {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Resolutions {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Resolutions {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Resolutions").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ResolveSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RESOLVE_SECTION
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ResolveSection {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ResolveSection {}
impl PartialEq for ResolveSection {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ResolveSection {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ResolveSection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ResolveSection").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ReturnParam {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RETURN_PARAM
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ReturnParam {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ReturnParam {}
impl PartialEq for ReturnParam {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ReturnParam {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ReturnParam {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ReturnParam").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ScopeNameDecl {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SCOPE_NAME_DECL
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ScopeNameDecl {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ScopeNameDecl {}
impl PartialEq for ScopeNameDecl {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ScopeNameDecl {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ScopeNameDecl {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ScopeNameDecl").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ScopeParams {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SCOPE_PARAMS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ScopeParams {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ScopeParams {}
impl PartialEq for ScopeParams {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ScopeParams {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ScopeParams {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ScopeParams").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ScopeRef {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SCOPE_REF
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ScopeRef {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ScopeRef {}
impl PartialEq for ScopeRef {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ScopeRef {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ScopeRef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ScopeRef").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ScopeType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SCOPE_TYPE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for ScopeType {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for ScopeType {}
impl PartialEq for ScopeType {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for ScopeType {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for ScopeType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ScopeType").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for SourceFile {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SOURCE_FILE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for SourceFile {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for SourceFile {}
impl PartialEq for SourceFile {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for SourceFile {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for SourceFile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("SourceFile").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for StringInclude {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRING_INCLUDE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for StringInclude {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for StringInclude {}
impl PartialEq for StringInclude {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for StringInclude {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for StringInclude {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("StringInclude").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for StringPart {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRING_PART
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for StringPart {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for StringPart {}
impl PartialEq for StringPart {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for StringPart {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for StringPart {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("StringPart").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for StringSeq {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRING_SEQ
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for StringSeq {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for StringSeq {}
impl PartialEq for StringSeq {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for StringSeq {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for StringSeq {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("StringSeq").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for SupportsQualifications {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SUPPORTS_QUALIFICATIONS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for SupportsQualifications {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for SupportsQualifications {}
impl PartialEq for SupportsQualifications {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for SupportsQualifications {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for SupportsQualifications {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("SupportsQualifications").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for TryStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRY_STMT
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for TryStmt {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for TryStmt {}
impl PartialEq for TryStmt {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for TryStmt {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for TryStmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("TryStmt").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Type {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for Type {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for Type {}
impl PartialEq for Type {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for Type {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for Type {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Type").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for TypeArg {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_ARG
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for TypeArg {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for TypeArg {}
impl PartialEq for TypeArg {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for TypeArg {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for TypeArg {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("TypeArg").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for TypeBound {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_BOUND
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for TypeBound {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for TypeBound {}
impl PartialEq for TypeBound {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for TypeBound {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for TypeBound {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("TypeBound").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for TypeBounds {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_BOUNDS
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for TypeBounds {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for TypeBounds {}
impl PartialEq for TypeBounds {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for TypeBounds {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for TypeBounds {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("TypeBounds").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for VarExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VAR_EXPR
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for VarExpr {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for VarExpr {}
impl PartialEq for VarExpr {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for VarExpr {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for VarExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("VarExpr").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for VarType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VAR_TYPE
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for VarType {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for VarType {}
impl PartialEq for VarType {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for VarType {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for VarType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("VarType").field("syntax", &self.syntax).finish()
    }
}
impl From<KeywordArg> for ApplyArg {
    #[inline]
    fn from(node: KeywordArg) -> ApplyArg {
        ApplyArg::KeywordArg(node)
    }
}
impl From<Expr> for ApplyArg {
    #[inline]
    fn from(node: Expr) -> ApplyArg {
        ApplyArg::Expr(node)
    }
}
impl AstNode for ApplyArg {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            KEYWORD_ARG => true,
            _ if Expr::can_cast(kind) => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            KEYWORD_ARG => Some(ApplyArg::KeywordArg(KeywordArg { syntax })),
            _ => {
                if Expr::can_cast(syntax.kind()) {
                    return Some(ApplyArg::Expr(Expr::cast(syntax).expect("cast failed")));
                }
                None
            }
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ApplyArg::KeywordArg(it) => &it.syntax,
            ApplyArg::Expr(it) => it.syntax(),
        }
    }
}
impl From<AccessTerm> for AtomStmt {
    #[inline]
    fn from(node: AccessTerm) -> AtomStmt {
        AtomStmt::AccessTerm(node)
    }
}
impl From<ApplyTerm> for AtomStmt {
    #[inline]
    fn from(node: ApplyTerm) -> AtomStmt {
        AtomStmt::ApplyTerm(node)
    }
}
impl From<AssignStmt> for AtomStmt {
    #[inline]
    fn from(node: AssignStmt) -> AtomStmt {
        AtomStmt::AssignStmt(node)
    }
}
impl From<CutStmt> for AtomStmt {
    #[inline]
    fn from(node: CutStmt) -> AtomStmt {
        AtomStmt::CutStmt(node)
    }
}
impl From<ForeachStmt> for AtomStmt {
    #[inline]
    fn from(node: ForeachStmt) -> AtomStmt {
        AtomStmt::ForeachStmt(node)
    }
}
impl From<IfTerm> for AtomStmt {
    #[inline]
    fn from(node: IfTerm) -> AtomStmt {
        AtomStmt::IfTerm(node)
    }
}
impl From<InStmt> for AtomStmt {
    #[inline]
    fn from(node: InStmt) -> AtomStmt {
        AtomStmt::InStmt(node)
    }
}
impl From<MatchStmt> for AtomStmt {
    #[inline]
    fn from(node: MatchStmt) -> AtomStmt {
        AtomStmt::MatchStmt(node)
    }
}
impl From<ParenTerm> for AtomStmt {
    #[inline]
    fn from(node: ParenTerm) -> AtomStmt {
        AtomStmt::ParenTerm(node)
    }
}
impl From<RefTerm> for AtomStmt {
    #[inline]
    fn from(node: RefTerm) -> AtomStmt {
        AtomStmt::RefTerm(node)
    }
}
impl From<RelationStmt> for AtomStmt {
    #[inline]
    fn from(node: RelationStmt) -> AtomStmt {
        AtomStmt::RelationStmt(node)
    }
}
impl From<TryStmt> for AtomStmt {
    #[inline]
    fn from(node: TryStmt) -> AtomStmt {
        AtomStmt::TryStmt(node)
    }
}
impl AstNode for AtomStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            ACCESS_TERM | APPLY_TERM | ASSIGN_STMT | CUT_STMT | FOREACH_STMT | IF_TERM
            | IN_STMT | MATCH_STMT | PAREN_TERM | REF_TERM | RELATION_STMT | TRY_STMT => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            ACCESS_TERM => Some(AtomStmt::AccessTerm(AccessTerm { syntax })),
            APPLY_TERM => Some(AtomStmt::ApplyTerm(ApplyTerm { syntax })),
            ASSIGN_STMT => Some(AtomStmt::AssignStmt(AssignStmt { syntax })),
            CUT_STMT => Some(AtomStmt::CutStmt(CutStmt { syntax })),
            FOREACH_STMT => Some(AtomStmt::ForeachStmt(ForeachStmt { syntax })),
            IF_TERM => Some(AtomStmt::IfTerm(IfTerm { syntax })),
            IN_STMT => Some(AtomStmt::InStmt(InStmt { syntax })),
            MATCH_STMT => Some(AtomStmt::MatchStmt(MatchStmt { syntax })),
            PAREN_TERM => Some(AtomStmt::ParenTerm(ParenTerm { syntax })),
            REF_TERM => Some(AtomStmt::RefTerm(RefTerm { syntax })),
            RELATION_STMT => Some(AtomStmt::RelationStmt(RelationStmt { syntax })),
            TRY_STMT => Some(AtomStmt::TryStmt(TryStmt { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AtomStmt::AccessTerm(it) => &it.syntax,
            AtomStmt::ApplyTerm(it) => &it.syntax,
            AtomStmt::AssignStmt(it) => &it.syntax,
            AtomStmt::CutStmt(it) => &it.syntax,
            AtomStmt::ForeachStmt(it) => &it.syntax,
            AtomStmt::IfTerm(it) => &it.syntax,
            AtomStmt::InStmt(it) => &it.syntax,
            AtomStmt::MatchStmt(it) => &it.syntax,
            AtomStmt::ParenTerm(it) => &it.syntax,
            AtomStmt::RefTerm(it) => &it.syntax,
            AtomStmt::RelationStmt(it) => &it.syntax,
            AtomStmt::TryStmt(it) => &it.syntax,
        }
    }
}
impl From<ClassFactFunctor> for ClassFact {
    #[inline]
    fn from(node: ClassFactFunctor) -> ClassFact {
        ClassFact::ClassFactFunctor(node)
    }
}
impl From<ClassFactVar> for ClassFact {
    #[inline]
    fn from(node: ClassFactVar) -> ClassFact {
        ClassFact::ClassFactVar(node)
    }
}
impl AstNode for ClassFact {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            CLASS_FACT_FUNCTOR | CLASS_FACT_VAR => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            CLASS_FACT_FUNCTOR => Some(ClassFact::ClassFactFunctor(ClassFactFunctor { syntax })),
            CLASS_FACT_VAR => Some(ClassFact::ClassFactVar(ClassFactVar { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ClassFact::ClassFactFunctor(it) => &it.syntax,
            ClassFact::ClassFactVar(it) => &it.syntax,
        }
    }
}
impl From<ConstantsSection> for ClassSection {
    #[inline]
    fn from(node: ConstantsSection) -> ClassSection {
        ClassSection::ConstantsSection(node)
    }
}
impl From<ConstructorsSection> for ClassSection {
    #[inline]
    fn from(node: ConstructorsSection) -> ClassSection {
        ClassSection::ConstructorsSection(node)
    }
}
impl From<DomainsSection> for ClassSection {
    #[inline]
    fn from(node: DomainsSection) -> ClassSection {
        ClassSection::DomainsSection(node)
    }
}
impl From<ErrorDirective> for ClassSection {
    #[inline]
    fn from(node: ErrorDirective) -> ClassSection {
        ClassSection::ErrorDirective(node)
    }
}
impl From<MessageDirective> for ClassSection {
    #[inline]
    fn from(node: MessageDirective) -> ClassSection {
        ClassSection::MessageDirective(node)
    }
}
impl From<PredicatesSection> for ClassSection {
    #[inline]
    fn from(node: PredicatesSection) -> ClassSection {
        ClassSection::PredicatesSection(node)
    }
}
impl From<PropertiesSection> for ClassSection {
    #[inline]
    fn from(node: PropertiesSection) -> ClassSection {
        ClassSection::PropertiesSection(node)
    }
}
impl From<RequiresDirective> for ClassSection {
    #[inline]
    fn from(node: RequiresDirective) -> ClassSection {
        ClassSection::RequiresDirective(node)
    }
}
impl AstNode for ClassSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            CONSTANTS_SECTION | CONSTRUCTORS_SECTION | DOMAINS_SECTION | ERROR_DIRECTIVE
            | MESSAGE_DIRECTIVE | PREDICATES_SECTION | PROPERTIES_SECTION | REQUIRES_DIRECTIVE => {
                true
            }
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            CONSTANTS_SECTION => Some(ClassSection::ConstantsSection(ConstantsSection { syntax })),
            CONSTRUCTORS_SECTION => {
                Some(ClassSection::ConstructorsSection(ConstructorsSection { syntax }))
            }
            DOMAINS_SECTION => Some(ClassSection::DomainsSection(DomainsSection { syntax })),
            ERROR_DIRECTIVE => Some(ClassSection::ErrorDirective(ErrorDirective { syntax })),
            MESSAGE_DIRECTIVE => Some(ClassSection::MessageDirective(MessageDirective { syntax })),
            PREDICATES_SECTION => {
                Some(ClassSection::PredicatesSection(PredicatesSection { syntax }))
            }
            PROPERTIES_SECTION => {
                Some(ClassSection::PropertiesSection(PropertiesSection { syntax }))
            }
            REQUIRES_DIRECTIVE => {
                Some(ClassSection::RequiresDirective(RequiresDirective { syntax }))
            }
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ClassSection::ConstantsSection(it) => &it.syntax,
            ClassSection::ConstructorsSection(it) => &it.syntax,
            ClassSection::DomainsSection(it) => &it.syntax,
            ClassSection::ErrorDirective(it) => &it.syntax,
            ClassSection::MessageDirective(it) => &it.syntax,
            ClassSection::PredicatesSection(it) => &it.syntax,
            ClassSection::PropertiesSection(it) => &it.syntax,
            ClassSection::RequiresDirective(it) => &it.syntax,
        }
    }
}
impl From<Clause> for ClauseKind {
    #[inline]
    fn from(node: Clause) -> ClauseKind {
        ClauseKind::Clause(node)
    }
}
impl From<GuardClause> for ClauseKind {
    #[inline]
    fn from(node: GuardClause) -> ClauseKind {
        ClauseKind::GuardClause(node)
    }
}
impl AstNode for ClauseKind {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            CLAUSE | GUARD_CLAUSE => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            CLAUSE => Some(ClauseKind::Clause(Clause { syntax })),
            GUARD_CLAUSE => Some(ClauseKind::GuardClause(GuardClause { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ClauseKind::Clause(it) => &it.syntax,
            ClauseKind::GuardClause(it) => &it.syntax,
        }
    }
}
impl From<InterfaceDelegate> for Delegate {
    #[inline]
    fn from(node: InterfaceDelegate) -> Delegate {
        Delegate::InterfaceDelegate(node)
    }
}
impl From<PredicateDelegate> for Delegate {
    #[inline]
    fn from(node: PredicateDelegate) -> Delegate {
        Delegate::PredicateDelegate(node)
    }
}
impl AstNode for Delegate {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            INTERFACE_DELEGATE | PREDICATE_DELEGATE => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            INTERFACE_DELEGATE => Some(Delegate::InterfaceDelegate(InterfaceDelegate { syntax })),
            PREDICATE_DELEGATE => Some(Delegate::PredicateDelegate(PredicateDelegate { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Delegate::InterfaceDelegate(it) => &it.syntax,
            Delegate::PredicateDelegate(it) => &it.syntax,
        }
    }
}
impl From<AliasDomain> for DomainDef {
    #[inline]
    fn from(node: AliasDomain) -> DomainDef {
        DomainDef::AliasDomain(node)
    }
}
impl From<FunctorDomain> for DomainDef {
    #[inline]
    fn from(node: FunctorDomain) -> DomainDef {
        DomainDef::FunctorDomain(node)
    }
}
impl From<NumericDomain> for DomainDef {
    #[inline]
    fn from(node: NumericDomain) -> DomainDef {
        DomainDef::NumericDomain(node)
    }
}
impl From<PredicateDomain> for DomainDef {
    #[inline]
    fn from(node: PredicateDomain) -> DomainDef {
        DomainDef::PredicateDomain(node)
    }
}
impl AstNode for DomainDef {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            ALIAS_DOMAIN | FUNCTOR_DOMAIN | NUMERIC_DOMAIN | PREDICATE_DOMAIN => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            ALIAS_DOMAIN => Some(DomainDef::AliasDomain(AliasDomain { syntax })),
            FUNCTOR_DOMAIN => Some(DomainDef::FunctorDomain(FunctorDomain { syntax })),
            NUMERIC_DOMAIN => Some(DomainDef::NumericDomain(NumericDomain { syntax })),
            PREDICATE_DOMAIN => Some(DomainDef::PredicateDomain(PredicateDomain { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            DomainDef::AliasDomain(it) => &it.syntax,
            DomainDef::FunctorDomain(it) => &it.syntax,
            DomainDef::NumericDomain(it) => &it.syntax,
            DomainDef::PredicateDomain(it) => &it.syntax,
        }
    }
}
impl From<AccessTerm> for Expr {
    #[inline]
    fn from(node: AccessTerm) -> Expr {
        Expr::AccessTerm(node)
    }
}
impl From<ApplyTerm> for Expr {
    #[inline]
    fn from(node: ApplyTerm) -> Expr {
        Expr::ApplyTerm(node)
    }
}
impl From<BinExpr> for Expr {
    #[inline]
    fn from(node: BinExpr) -> Expr {
        Expr::BinExpr(node)
    }
}
impl From<BinInclude> for Expr {
    #[inline]
    fn from(node: BinInclude) -> Expr {
        Expr::BinInclude(node)
    }
}
impl From<BinLiteral> for Expr {
    #[inline]
    fn from(node: BinLiteral) -> Expr {
        Expr::BinLiteral(node)
    }
}
impl From<ConsExpr> for Expr {
    #[inline]
    fn from(node: ConsExpr) -> Expr {
        Expr::ConsExpr(node)
    }
}
impl From<Ellipsis> for Expr {
    #[inline]
    fn from(node: Ellipsis) -> Expr {
        Expr::Ellipsis(node)
    }
}
impl From<FindAllExpr> for Expr {
    #[inline]
    fn from(node: FindAllExpr) -> Expr {
        Expr::FindAllExpr(node)
    }
}
impl From<IfTerm> for Expr {
    #[inline]
    fn from(node: IfTerm) -> Expr {
        Expr::IfTerm(node)
    }
}
impl From<LambdaExpr> for Expr {
    #[inline]
    fn from(node: LambdaExpr) -> Expr {
        Expr::LambdaExpr(node)
    }
}
impl From<ListExpr> for Expr {
    #[inline]
    fn from(node: ListExpr) -> Expr {
        Expr::ListExpr(node)
    }
}
impl From<NumericLiteral> for Expr {
    #[inline]
    fn from(node: NumericLiteral) -> Expr {
        Expr::NumericLiteral(node)
    }
}
impl From<ObjectExpr> for Expr {
    #[inline]
    fn from(node: ObjectExpr) -> Expr {
        Expr::ObjectExpr(node)
    }
}
impl From<ParenTerm> for Expr {
    #[inline]
    fn from(node: ParenTerm) -> Expr {
        Expr::ParenTerm(node)
    }
}
impl From<PrefixExpr> for Expr {
    #[inline]
    fn from(node: PrefixExpr) -> Expr {
        Expr::PrefixExpr(node)
    }
}
impl From<RefTerm> for Expr {
    #[inline]
    fn from(node: RefTerm) -> Expr {
        Expr::RefTerm(node)
    }
}
impl From<ScopeType> for Expr {
    #[inline]
    fn from(node: ScopeType) -> Expr {
        Expr::ScopeType(node)
    }
}
impl From<StringInclude> for Expr {
    #[inline]
    fn from(node: StringInclude) -> Expr {
        Expr::StringInclude(node)
    }
}
impl From<StringSeq> for Expr {
    #[inline]
    fn from(node: StringSeq) -> Expr {
        Expr::StringSeq(node)
    }
}
impl From<VarExpr> for Expr {
    #[inline]
    fn from(node: VarExpr) -> Expr {
        Expr::VarExpr(node)
    }
}
impl AstNode for Expr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            ACCESS_TERM | APPLY_TERM | BIN_EXPR | BIN_INCLUDE | BIN_LITERAL | CONS_EXPR
            | ELLIPSIS | FIND_ALL_EXPR | IF_TERM | LAMBDA_EXPR | LIST_EXPR | NUMERIC_LITERAL
            | OBJECT_EXPR | PAREN_TERM | PREFIX_EXPR | REF_TERM | SCOPE_TYPE | STRING_INCLUDE
            | STRING_SEQ | VAR_EXPR => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            ACCESS_TERM => Some(Expr::AccessTerm(AccessTerm { syntax })),
            APPLY_TERM => Some(Expr::ApplyTerm(ApplyTerm { syntax })),
            BIN_EXPR => Some(Expr::BinExpr(BinExpr { syntax })),
            BIN_INCLUDE => Some(Expr::BinInclude(BinInclude { syntax })),
            BIN_LITERAL => Some(Expr::BinLiteral(BinLiteral { syntax })),
            CONS_EXPR => Some(Expr::ConsExpr(ConsExpr { syntax })),
            ELLIPSIS => Some(Expr::Ellipsis(Ellipsis { syntax })),
            FIND_ALL_EXPR => Some(Expr::FindAllExpr(FindAllExpr { syntax })),
            IF_TERM => Some(Expr::IfTerm(IfTerm { syntax })),
            LAMBDA_EXPR => Some(Expr::LambdaExpr(LambdaExpr { syntax })),
            LIST_EXPR => Some(Expr::ListExpr(ListExpr { syntax })),
            NUMERIC_LITERAL => Some(Expr::NumericLiteral(NumericLiteral { syntax })),
            OBJECT_EXPR => Some(Expr::ObjectExpr(ObjectExpr { syntax })),
            PAREN_TERM => Some(Expr::ParenTerm(ParenTerm { syntax })),
            PREFIX_EXPR => Some(Expr::PrefixExpr(PrefixExpr { syntax })),
            REF_TERM => Some(Expr::RefTerm(RefTerm { syntax })),
            SCOPE_TYPE => Some(Expr::ScopeType(ScopeType { syntax })),
            STRING_INCLUDE => Some(Expr::StringInclude(StringInclude { syntax })),
            STRING_SEQ => Some(Expr::StringSeq(StringSeq { syntax })),
            VAR_EXPR => Some(Expr::VarExpr(VarExpr { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::AccessTerm(it) => &it.syntax,
            Expr::ApplyTerm(it) => &it.syntax,
            Expr::BinExpr(it) => &it.syntax,
            Expr::BinInclude(it) => &it.syntax,
            Expr::BinLiteral(it) => &it.syntax,
            Expr::ConsExpr(it) => &it.syntax,
            Expr::Ellipsis(it) => &it.syntax,
            Expr::FindAllExpr(it) => &it.syntax,
            Expr::IfTerm(it) => &it.syntax,
            Expr::LambdaExpr(it) => &it.syntax,
            Expr::ListExpr(it) => &it.syntax,
            Expr::NumericLiteral(it) => &it.syntax,
            Expr::ObjectExpr(it) => &it.syntax,
            Expr::ParenTerm(it) => &it.syntax,
            Expr::PrefixExpr(it) => &it.syntax,
            Expr::RefTerm(it) => &it.syntax,
            Expr::ScopeType(it) => &it.syntax,
            Expr::StringInclude(it) => &it.syntax,
            Expr::StringSeq(it) => &it.syntax,
            Expr::VarExpr(it) => &it.syntax,
        }
    }
}
impl From<FactFunctor> for Fact {
    #[inline]
    fn from(node: FactFunctor) -> Fact {
        Fact::FactFunctor(node)
    }
}
impl From<FactVar> for Fact {
    #[inline]
    fn from(node: FactVar) -> Fact {
        Fact::FactVar(node)
    }
}
impl AstNode for Fact {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            FACT_FUNCTOR | FACT_VAR => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            FACT_FUNCTOR => Some(Fact::FactFunctor(FactFunctor { syntax })),
            FACT_VAR => Some(Fact::FactVar(FactVar { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Fact::FactFunctor(it) => &it.syntax,
            Fact::FactVar(it) => &it.syntax,
        }
    }
}
impl From<Ellipsis> for FlowArg {
    #[inline]
    fn from(node: Ellipsis) -> FlowArg {
        FlowArg::Ellipsis(node)
    }
}
impl From<FlowDirection> for FlowArg {
    #[inline]
    fn from(node: FlowDirection) -> FlowArg {
        FlowArg::FlowDirection(node)
    }
}
impl From<FunctorFlow> for FlowArg {
    #[inline]
    fn from(node: FunctorFlow) -> FlowArg {
        FlowArg::FunctorFlow(node)
    }
}
impl From<ListFlow> for FlowArg {
    #[inline]
    fn from(node: ListFlow) -> FlowArg {
        FlowArg::ListFlow(node)
    }
}
impl AstNode for FlowArg {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            ELLIPSIS | FLOW_DIRECTION | FUNCTOR_FLOW | LIST_FLOW => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            ELLIPSIS => Some(FlowArg::Ellipsis(Ellipsis { syntax })),
            FLOW_DIRECTION => Some(FlowArg::FlowDirection(FlowDirection { syntax })),
            FUNCTOR_FLOW => Some(FlowArg::FunctorFlow(FunctorFlow { syntax })),
            LIST_FLOW => Some(FlowArg::ListFlow(ListFlow { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            FlowArg::Ellipsis(it) => &it.syntax,
            FlowArg::FlowDirection(it) => &it.syntax,
            FlowArg::FunctorFlow(it) => &it.syntax,
            FlowArg::ListFlow(it) => &it.syntax,
        }
    }
}
impl From<AnyFlow> for FlowPattern {
    #[inline]
    fn from(node: AnyFlow) -> FlowPattern {
        FlowPattern::AnyFlow(node)
    }
}
impl From<Flow> for FlowPattern {
    #[inline]
    fn from(node: Flow) -> FlowPattern {
        FlowPattern::Flow(node)
    }
}
impl AstNode for FlowPattern {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            ANY_FLOW | FLOW => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            ANY_FLOW => Some(FlowPattern::AnyFlow(AnyFlow { syntax })),
            FLOW => Some(FlowPattern::Flow(Flow { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            FlowPattern::AnyFlow(it) => &it.syntax,
            FlowPattern::Flow(it) => &it.syntax,
        }
    }
}
impl From<KeywordArg> for FunctorArg {
    #[inline]
    fn from(node: KeywordArg) -> FunctorArg {
        FunctorArg::KeywordArg(node)
    }
}
impl From<AtomStmt> for FunctorArg {
    #[inline]
    fn from(node: AtomStmt) -> FunctorArg {
        FunctorArg::AtomStmt(node)
    }
}
impl From<Expr> for FunctorArg {
    #[inline]
    fn from(node: Expr) -> FunctorArg {
        FunctorArg::Expr(node)
    }
}
impl AstNode for FunctorArg {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            KEYWORD_ARG => true,
            _ if AtomStmt::can_cast(kind) => true,
            _ if Expr::can_cast(kind) => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            KEYWORD_ARG => Some(FunctorArg::KeywordArg(KeywordArg { syntax })),
            _ => {
                if AtomStmt::can_cast(syntax.kind()) {
                    return Some(FunctorArg::AtomStmt(
                        AtomStmt::cast(syntax).expect("cast failed"),
                    ));
                }
                if Expr::can_cast(syntax.kind()) {
                    return Some(FunctorArg::Expr(Expr::cast(syntax).expect("cast failed")));
                }
                None
            }
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            FunctorArg::KeywordArg(it) => &it.syntax,
            FunctorArg::AtomStmt(it) => it.syntax(),
            FunctorArg::Expr(it) => it.syntax(),
        }
    }
}
impl From<InheritsQualifications> for ImplementQualification {
    #[inline]
    fn from(node: InheritsQualifications) -> ImplementQualification {
        ImplementQualification::InheritsQualifications(node)
    }
}
impl From<OpenQualifications> for ImplementQualification {
    #[inline]
    fn from(node: OpenQualifications) -> ImplementQualification {
        ImplementQualification::OpenQualifications(node)
    }
}
impl From<SupportsQualifications> for ImplementQualification {
    #[inline]
    fn from(node: SupportsQualifications) -> ImplementQualification {
        ImplementQualification::SupportsQualifications(node)
    }
}
impl AstNode for ImplementQualification {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            INHERITS_QUALIFICATIONS | OPEN_QUALIFICATIONS | SUPPORTS_QUALIFICATIONS => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            INHERITS_QUALIFICATIONS => {
                Some(ImplementQualification::InheritsQualifications(InheritsQualifications {
                    syntax,
                }))
            }
            OPEN_QUALIFICATIONS => {
                Some(ImplementQualification::OpenQualifications(OpenQualifications { syntax }))
            }
            SUPPORTS_QUALIFICATIONS => {
                Some(ImplementQualification::SupportsQualifications(SupportsQualifications {
                    syntax,
                }))
            }
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ImplementQualification::InheritsQualifications(it) => &it.syntax,
            ImplementQualification::OpenQualifications(it) => &it.syntax,
            ImplementQualification::SupportsQualifications(it) => &it.syntax,
        }
    }
}
impl From<ClassFactsSection> for ImplementSection {
    #[inline]
    fn from(node: ClassFactsSection) -> ImplementSection {
        ImplementSection::ClassFactsSection(node)
    }
}
impl From<ClassPredicatesSection> for ImplementSection {
    #[inline]
    fn from(node: ClassPredicatesSection) -> ImplementSection {
        ImplementSection::ClassPredicatesSection(node)
    }
}
impl From<ClassPropertiesSection> for ImplementSection {
    #[inline]
    fn from(node: ClassPropertiesSection) -> ImplementSection {
        ImplementSection::ClassPropertiesSection(node)
    }
}
impl From<ClausesSection> for ImplementSection {
    #[inline]
    fn from(node: ClausesSection) -> ImplementSection {
        ImplementSection::ClausesSection(node)
    }
}
impl From<ConstantsSection> for ImplementSection {
    #[inline]
    fn from(node: ConstantsSection) -> ImplementSection {
        ImplementSection::ConstantsSection(node)
    }
}
impl From<ConstructorsSection> for ImplementSection {
    #[inline]
    fn from(node: ConstructorsSection) -> ImplementSection {
        ImplementSection::ConstructorsSection(node)
    }
}
impl From<DelegateSection> for ImplementSection {
    #[inline]
    fn from(node: DelegateSection) -> ImplementSection {
        ImplementSection::DelegateSection(node)
    }
}
impl From<DomainsSection> for ImplementSection {
    #[inline]
    fn from(node: DomainsSection) -> ImplementSection {
        ImplementSection::DomainsSection(node)
    }
}
impl From<ErrorDirective> for ImplementSection {
    #[inline]
    fn from(node: ErrorDirective) -> ImplementSection {
        ImplementSection::ErrorDirective(node)
    }
}
impl From<FactsSection> for ImplementSection {
    #[inline]
    fn from(node: FactsSection) -> ImplementSection {
        ImplementSection::FactsSection(node)
    }
}
impl From<MessageDirective> for ImplementSection {
    #[inline]
    fn from(node: MessageDirective) -> ImplementSection {
        ImplementSection::MessageDirective(node)
    }
}
impl From<PredicatesSection> for ImplementSection {
    #[inline]
    fn from(node: PredicatesSection) -> ImplementSection {
        ImplementSection::PredicatesSection(node)
    }
}
impl From<PropertiesSection> for ImplementSection {
    #[inline]
    fn from(node: PropertiesSection) -> ImplementSection {
        ImplementSection::PropertiesSection(node)
    }
}
impl From<RequiresDirective> for ImplementSection {
    #[inline]
    fn from(node: RequiresDirective) -> ImplementSection {
        ImplementSection::RequiresDirective(node)
    }
}
impl From<ResolveSection> for ImplementSection {
    #[inline]
    fn from(node: ResolveSection) -> ImplementSection {
        ImplementSection::ResolveSection(node)
    }
}
impl AstNode for ImplementSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            CLASS_FACTS_SECTION
            | CLASS_PREDICATES_SECTION
            | CLASS_PROPERTIES_SECTION
            | CLAUSES_SECTION
            | CONSTANTS_SECTION
            | CONSTRUCTORS_SECTION
            | DELEGATE_SECTION
            | DOMAINS_SECTION
            | ERROR_DIRECTIVE
            | FACTS_SECTION
            | MESSAGE_DIRECTIVE
            | PREDICATES_SECTION
            | PROPERTIES_SECTION
            | REQUIRES_DIRECTIVE
            | RESOLVE_SECTION => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            CLASS_FACTS_SECTION => {
                Some(ImplementSection::ClassFactsSection(ClassFactsSection { syntax }))
            }
            CLASS_PREDICATES_SECTION => {
                Some(ImplementSection::ClassPredicatesSection(ClassPredicatesSection { syntax }))
            }
            CLASS_PROPERTIES_SECTION => {
                Some(ImplementSection::ClassPropertiesSection(ClassPropertiesSection { syntax }))
            }
            CLAUSES_SECTION => Some(ImplementSection::ClausesSection(ClausesSection { syntax })),
            CONSTANTS_SECTION => {
                Some(ImplementSection::ConstantsSection(ConstantsSection { syntax }))
            }
            CONSTRUCTORS_SECTION => {
                Some(ImplementSection::ConstructorsSection(ConstructorsSection { syntax }))
            }
            DELEGATE_SECTION => Some(ImplementSection::DelegateSection(DelegateSection { syntax })),
            DOMAINS_SECTION => Some(ImplementSection::DomainsSection(DomainsSection { syntax })),
            ERROR_DIRECTIVE => Some(ImplementSection::ErrorDirective(ErrorDirective { syntax })),
            FACTS_SECTION => Some(ImplementSection::FactsSection(FactsSection { syntax })),
            MESSAGE_DIRECTIVE => {
                Some(ImplementSection::MessageDirective(MessageDirective { syntax }))
            }
            PREDICATES_SECTION => {
                Some(ImplementSection::PredicatesSection(PredicatesSection { syntax }))
            }
            PROPERTIES_SECTION => {
                Some(ImplementSection::PropertiesSection(PropertiesSection { syntax }))
            }
            REQUIRES_DIRECTIVE => {
                Some(ImplementSection::RequiresDirective(RequiresDirective { syntax }))
            }
            RESOLVE_SECTION => Some(ImplementSection::ResolveSection(ResolveSection { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ImplementSection::ClassFactsSection(it) => &it.syntax,
            ImplementSection::ClassPredicatesSection(it) => &it.syntax,
            ImplementSection::ClassPropertiesSection(it) => &it.syntax,
            ImplementSection::ClausesSection(it) => &it.syntax,
            ImplementSection::ConstantsSection(it) => &it.syntax,
            ImplementSection::ConstructorsSection(it) => &it.syntax,
            ImplementSection::DelegateSection(it) => &it.syntax,
            ImplementSection::DomainsSection(it) => &it.syntax,
            ImplementSection::ErrorDirective(it) => &it.syntax,
            ImplementSection::FactsSection(it) => &it.syntax,
            ImplementSection::MessageDirective(it) => &it.syntax,
            ImplementSection::PredicatesSection(it) => &it.syntax,
            ImplementSection::PropertiesSection(it) => &it.syntax,
            ImplementSection::RequiresDirective(it) => &it.syntax,
            ImplementSection::ResolveSection(it) => &it.syntax,
        }
    }
}
impl From<OpenQualifications> for InterfaceQualification {
    #[inline]
    fn from(node: OpenQualifications) -> InterfaceQualification {
        InterfaceQualification::OpenQualifications(node)
    }
}
impl From<SupportsQualifications> for InterfaceQualification {
    #[inline]
    fn from(node: SupportsQualifications) -> InterfaceQualification {
        InterfaceQualification::SupportsQualifications(node)
    }
}
impl AstNode for InterfaceQualification {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            OPEN_QUALIFICATIONS | SUPPORTS_QUALIFICATIONS => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            OPEN_QUALIFICATIONS => {
                Some(InterfaceQualification::OpenQualifications(OpenQualifications { syntax }))
            }
            SUPPORTS_QUALIFICATIONS => {
                Some(InterfaceQualification::SupportsQualifications(SupportsQualifications {
                    syntax,
                }))
            }
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            InterfaceQualification::OpenQualifications(it) => &it.syntax,
            InterfaceQualification::SupportsQualifications(it) => &it.syntax,
        }
    }
}
impl From<ConstantsSection> for InterfaceSection {
    #[inline]
    fn from(node: ConstantsSection) -> InterfaceSection {
        InterfaceSection::ConstantsSection(node)
    }
}
impl From<DomainsSection> for InterfaceSection {
    #[inline]
    fn from(node: DomainsSection) -> InterfaceSection {
        InterfaceSection::DomainsSection(node)
    }
}
impl From<ErrorDirective> for InterfaceSection {
    #[inline]
    fn from(node: ErrorDirective) -> InterfaceSection {
        InterfaceSection::ErrorDirective(node)
    }
}
impl From<MessageDirective> for InterfaceSection {
    #[inline]
    fn from(node: MessageDirective) -> InterfaceSection {
        InterfaceSection::MessageDirective(node)
    }
}
impl From<PredicatesFromSection> for InterfaceSection {
    #[inline]
    fn from(node: PredicatesFromSection) -> InterfaceSection {
        InterfaceSection::PredicatesFromSection(node)
    }
}
impl From<PredicatesSection> for InterfaceSection {
    #[inline]
    fn from(node: PredicatesSection) -> InterfaceSection {
        InterfaceSection::PredicatesSection(node)
    }
}
impl From<PropertiesFromSection> for InterfaceSection {
    #[inline]
    fn from(node: PropertiesFromSection) -> InterfaceSection {
        InterfaceSection::PropertiesFromSection(node)
    }
}
impl From<PropertiesSection> for InterfaceSection {
    #[inline]
    fn from(node: PropertiesSection) -> InterfaceSection {
        InterfaceSection::PropertiesSection(node)
    }
}
impl From<RequiresDirective> for InterfaceSection {
    #[inline]
    fn from(node: RequiresDirective) -> InterfaceSection {
        InterfaceSection::RequiresDirective(node)
    }
}
impl AstNode for InterfaceSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            CONSTANTS_SECTION
            | DOMAINS_SECTION
            | ERROR_DIRECTIVE
            | MESSAGE_DIRECTIVE
            | PREDICATES_FROM_SECTION
            | PREDICATES_SECTION
            | PROPERTIES_FROM_SECTION
            | PROPERTIES_SECTION
            | REQUIRES_DIRECTIVE => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            CONSTANTS_SECTION => {
                Some(InterfaceSection::ConstantsSection(ConstantsSection { syntax }))
            }
            DOMAINS_SECTION => Some(InterfaceSection::DomainsSection(DomainsSection { syntax })),
            ERROR_DIRECTIVE => Some(InterfaceSection::ErrorDirective(ErrorDirective { syntax })),
            MESSAGE_DIRECTIVE => {
                Some(InterfaceSection::MessageDirective(MessageDirective { syntax }))
            }
            PREDICATES_FROM_SECTION => {
                Some(InterfaceSection::PredicatesFromSection(PredicatesFromSection { syntax }))
            }
            PREDICATES_SECTION => {
                Some(InterfaceSection::PredicatesSection(PredicatesSection { syntax }))
            }
            PROPERTIES_FROM_SECTION => {
                Some(InterfaceSection::PropertiesFromSection(PropertiesFromSection { syntax }))
            }
            PROPERTIES_SECTION => {
                Some(InterfaceSection::PropertiesSection(PropertiesSection { syntax }))
            }
            REQUIRES_DIRECTIVE => {
                Some(InterfaceSection::RequiresDirective(RequiresDirective { syntax }))
            }
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            InterfaceSection::ConstantsSection(it) => &it.syntax,
            InterfaceSection::DomainsSection(it) => &it.syntax,
            InterfaceSection::ErrorDirective(it) => &it.syntax,
            InterfaceSection::MessageDirective(it) => &it.syntax,
            InterfaceSection::PredicatesFromSection(it) => &it.syntax,
            InterfaceSection::PredicatesSection(it) => &it.syntax,
            InterfaceSection::PropertiesFromSection(it) => &it.syntax,
            InterfaceSection::PropertiesSection(it) => &it.syntax,
            InterfaceSection::RequiresDirective(it) => &it.syntax,
        }
    }
}
impl From<ClassItem> for Item {
    #[inline]
    fn from(node: ClassItem) -> Item {
        Item::ClassItem(node)
    }
}
impl From<ErrorDirective> for Item {
    #[inline]
    fn from(node: ErrorDirective) -> Item {
        Item::ErrorDirective(node)
    }
}
impl From<ExportItem> for Item {
    #[inline]
    fn from(node: ExportItem) -> Item {
        Item::ExportItem(node)
    }
}
impl From<ExternallyItem> for Item {
    #[inline]
    fn from(node: ExternallyItem) -> Item {
        Item::ExternallyItem(node)
    }
}
impl From<GoalItem> for Item {
    #[inline]
    fn from(node: GoalItem) -> Item {
        Item::GoalItem(node)
    }
}
impl From<ImplementItem> for Item {
    #[inline]
    fn from(node: ImplementItem) -> Item {
        Item::ImplementItem(node)
    }
}
impl From<IncludeItem> for Item {
    #[inline]
    fn from(node: IncludeItem) -> Item {
        Item::IncludeItem(node)
    }
}
impl From<InterfaceItem> for Item {
    #[inline]
    fn from(node: InterfaceItem) -> Item {
        Item::InterfaceItem(node)
    }
}
impl From<MessageDirective> for Item {
    #[inline]
    fn from(node: MessageDirective) -> Item {
        Item::MessageDirective(node)
    }
}
impl From<NamespaceItem> for Item {
    #[inline]
    fn from(node: NamespaceItem) -> Item {
        Item::NamespaceItem(node)
    }
}
impl From<OptionsItem> for Item {
    #[inline]
    fn from(node: OptionsItem) -> Item {
        Item::OptionsItem(node)
    }
}
impl From<RequiresDirective> for Item {
    #[inline]
    fn from(node: RequiresDirective) -> Item {
        Item::RequiresDirective(node)
    }
}
impl AstNode for Item {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            CLASS_ITEM | ERROR_DIRECTIVE | EXPORT_ITEM | EXTERNALLY_ITEM | GOAL_ITEM
            | IMPLEMENT_ITEM | INCLUDE_ITEM | INTERFACE_ITEM | MESSAGE_DIRECTIVE
            | NAMESPACE_ITEM | OPTIONS_ITEM | REQUIRES_DIRECTIVE => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            CLASS_ITEM => Some(Item::ClassItem(ClassItem { syntax })),
            ERROR_DIRECTIVE => Some(Item::ErrorDirective(ErrorDirective { syntax })),
            EXPORT_ITEM => Some(Item::ExportItem(ExportItem { syntax })),
            EXTERNALLY_ITEM => Some(Item::ExternallyItem(ExternallyItem { syntax })),
            GOAL_ITEM => Some(Item::GoalItem(GoalItem { syntax })),
            IMPLEMENT_ITEM => Some(Item::ImplementItem(ImplementItem { syntax })),
            INCLUDE_ITEM => Some(Item::IncludeItem(IncludeItem { syntax })),
            INTERFACE_ITEM => Some(Item::InterfaceItem(InterfaceItem { syntax })),
            MESSAGE_DIRECTIVE => Some(Item::MessageDirective(MessageDirective { syntax })),
            NAMESPACE_ITEM => Some(Item::NamespaceItem(NamespaceItem { syntax })),
            OPTIONS_ITEM => Some(Item::OptionsItem(OptionsItem { syntax })),
            REQUIRES_DIRECTIVE => Some(Item::RequiresDirective(RequiresDirective { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Item::ClassItem(it) => &it.syntax,
            Item::ErrorDirective(it) => &it.syntax,
            Item::ExportItem(it) => &it.syntax,
            Item::ExternallyItem(it) => &it.syntax,
            Item::GoalItem(it) => &it.syntax,
            Item::ImplementItem(it) => &it.syntax,
            Item::IncludeItem(it) => &it.syntax,
            Item::InterfaceItem(it) => &it.syntax,
            Item::MessageDirective(it) => &it.syntax,
            Item::NamespaceItem(it) => &it.syntax,
            Item::OptionsItem(it) => &it.syntax,
            Item::RequiresDirective(it) => &it.syntax,
        }
    }
}
impl From<ExportItem> for ItemCondition {
    #[inline]
    fn from(node: ExportItem) -> ItemCondition {
        ItemCondition::ExportItem(node)
    }
}
impl From<Stmt> for ItemCondition {
    #[inline]
    fn from(node: Stmt) -> ItemCondition {
        ItemCondition::Stmt(node)
    }
}
impl AstNode for ItemCondition {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            EXPORT_ITEM => true,
            _ if Stmt::can_cast(kind) => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            EXPORT_ITEM => Some(ItemCondition::ExportItem(ExportItem { syntax })),
            _ => {
                if Stmt::can_cast(syntax.kind()) {
                    return Some(ItemCondition::Stmt(Stmt::cast(syntax).expect("cast failed")));
                }
                None
            }
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ItemCondition::ExportItem(it) => &it.syntax,
            ItemCondition::Stmt(it) => it.syntax(),
        }
    }
}
impl From<NamespacePath> for OpenQualification {
    #[inline]
    fn from(node: NamespacePath) -> OpenQualification {
        OpenQualification::NamespacePath(node)
    }
}
impl From<ScopeRef> for OpenQualification {
    #[inline]
    fn from(node: ScopeRef) -> OpenQualification {
        OpenQualification::ScopeRef(node)
    }
}
impl AstNode for OpenQualification {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            NAMESPACE_PATH | SCOPE_REF => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            NAMESPACE_PATH => Some(OpenQualification::NamespacePath(NamespacePath { syntax })),
            SCOPE_REF => Some(OpenQualification::ScopeRef(ScopeRef { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            OpenQualification::NamespacePath(it) => &it.syntax,
            OpenQualification::ScopeRef(it) => &it.syntax,
        }
    }
}
impl From<InlineParams> for PredParams {
    #[inline]
    fn from(node: InlineParams) -> PredParams {
        PredParams::InlineParams(node)
    }
}
impl From<RefTerm> for PredParams {
    #[inline]
    fn from(node: RefTerm) -> PredParams {
        PredParams::RefTerm(node)
    }
}
impl AstNode for PredParams {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            INLINE_PARAMS | REF_TERM => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            INLINE_PARAMS => Some(PredParams::InlineParams(InlineParams { syntax })),
            REF_TERM => Some(PredParams::RefTerm(RefTerm { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            PredParams::InlineParams(it) => &it.syntax,
            PredParams::RefTerm(it) => &it.syntax,
        }
    }
}
impl From<CondClassSection> for RecClassSection {
    #[inline]
    fn from(node: CondClassSection) -> RecClassSection {
        RecClassSection::CondClassSection(node)
    }
}
impl From<ClassSection> for RecClassSection {
    #[inline]
    fn from(node: ClassSection) -> RecClassSection {
        RecClassSection::ClassSection(node)
    }
}
impl AstNode for RecClassSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            COND_CLASS_SECTION => true,
            _ if ClassSection::can_cast(kind) => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            COND_CLASS_SECTION => {
                Some(RecClassSection::CondClassSection(CondClassSection { syntax }))
            }
            _ => {
                if ClassSection::can_cast(syntax.kind()) {
                    return Some(RecClassSection::ClassSection(
                        ClassSection::cast(syntax).expect("cast failed"),
                    ));
                }
                None
            }
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            RecClassSection::CondClassSection(it) => &it.syntax,
            RecClassSection::ClassSection(it) => it.syntax(),
        }
    }
}
impl From<CondImplementSection> for RecImplementSection {
    #[inline]
    fn from(node: CondImplementSection) -> RecImplementSection {
        RecImplementSection::CondImplementSection(node)
    }
}
impl From<ImplementSection> for RecImplementSection {
    #[inline]
    fn from(node: ImplementSection) -> RecImplementSection {
        RecImplementSection::ImplementSection(node)
    }
}
impl AstNode for RecImplementSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            COND_IMPLEMENT_SECTION => true,
            _ if ImplementSection::can_cast(kind) => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            COND_IMPLEMENT_SECTION => {
                Some(RecImplementSection::CondImplementSection(CondImplementSection { syntax }))
            }
            _ => {
                if ImplementSection::can_cast(syntax.kind()) {
                    return Some(RecImplementSection::ImplementSection(
                        ImplementSection::cast(syntax).expect("cast failed"),
                    ));
                }
                None
            }
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            RecImplementSection::CondImplementSection(it) => &it.syntax,
            RecImplementSection::ImplementSection(it) => it.syntax(),
        }
    }
}
impl From<CondInterfaceSection> for RecInterfaceSection {
    #[inline]
    fn from(node: CondInterfaceSection) -> RecInterfaceSection {
        RecInterfaceSection::CondInterfaceSection(node)
    }
}
impl From<InterfaceSection> for RecInterfaceSection {
    #[inline]
    fn from(node: InterfaceSection) -> RecInterfaceSection {
        RecInterfaceSection::InterfaceSection(node)
    }
}
impl AstNode for RecInterfaceSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            COND_INTERFACE_SECTION => true,
            _ if InterfaceSection::can_cast(kind) => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            COND_INTERFACE_SECTION => {
                Some(RecInterfaceSection::CondInterfaceSection(CondInterfaceSection { syntax }))
            }
            _ => {
                if InterfaceSection::can_cast(syntax.kind()) {
                    return Some(RecInterfaceSection::InterfaceSection(
                        InterfaceSection::cast(syntax).expect("cast failed"),
                    ));
                }
                None
            }
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            RecInterfaceSection::CondInterfaceSection(it) => &it.syntax,
            RecInterfaceSection::InterfaceSection(it) => it.syntax(),
        }
    }
}
impl From<CondItem> for RecItem {
    #[inline]
    fn from(node: CondItem) -> RecItem {
        RecItem::CondItem(node)
    }
}
impl From<Item> for RecItem {
    #[inline]
    fn from(node: Item) -> RecItem {
        RecItem::Item(node)
    }
}
impl AstNode for RecItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            COND_ITEM => true,
            _ if Item::can_cast(kind) => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            COND_ITEM => Some(RecItem::CondItem(CondItem { syntax })),
            _ => {
                if Item::can_cast(syntax.kind()) {
                    return Some(RecItem::Item(Item::cast(syntax).expect("cast failed")));
                }
                None
            }
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            RecItem::CondItem(it) => &it.syntax,
            RecItem::Item(it) => it.syntax(),
        }
    }
}
impl From<ExternalPredicateResolution> for Resolution {
    #[inline]
    fn from(node: ExternalPredicateResolution) -> Resolution {
        Resolution::ExternalPredicateResolution(node)
    }
}
impl From<InterfaceResolution> for Resolution {
    #[inline]
    fn from(node: InterfaceResolution) -> Resolution {
        Resolution::InterfaceResolution(node)
    }
}
impl From<PredicateResolution> for Resolution {
    #[inline]
    fn from(node: PredicateResolution) -> Resolution {
        Resolution::PredicateResolution(node)
    }
}
impl AstNode for Resolution {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            EXTERNAL_PREDICATE_RESOLUTION | INTERFACE_RESOLUTION | PREDICATE_RESOLUTION => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            EXTERNAL_PREDICATE_RESOLUTION => {
                Some(Resolution::ExternalPredicateResolution(ExternalPredicateResolution {
                    syntax,
                }))
            }
            INTERFACE_RESOLUTION => {
                Some(Resolution::InterfaceResolution(InterfaceResolution { syntax }))
            }
            PREDICATE_RESOLUTION => {
                Some(Resolution::PredicateResolution(PredicateResolution { syntax }))
            }
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Resolution::ExternalPredicateResolution(it) => &it.syntax,
            Resolution::InterfaceResolution(it) => &it.syntax,
            Resolution::PredicateResolution(it) => &it.syntax,
        }
    }
}
impl From<BinStmt> for Stmt {
    #[inline]
    fn from(node: BinStmt) -> Stmt {
        Stmt::BinStmt(node)
    }
}
impl From<AtomStmt> for Stmt {
    #[inline]
    fn from(node: AtomStmt) -> Stmt {
        Stmt::AtomStmt(node)
    }
}
impl AstNode for Stmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            BIN_STMT => true,
            _ if AtomStmt::can_cast(kind) => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            BIN_STMT => Some(Stmt::BinStmt(BinStmt { syntax })),
            _ => {
                if AtomStmt::can_cast(syntax.kind()) {
                    return Some(Stmt::AtomStmt(AtomStmt::cast(syntax).expect("cast failed")));
                }
                None
            }
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Stmt::BinStmt(it) => &it.syntax,
            Stmt::AtomStmt(it) => it.syntax(),
        }
    }
}
impl From<RefTerm> for StringOrConst {
    #[inline]
    fn from(node: RefTerm) -> StringOrConst {
        StringOrConst::RefTerm(node)
    }
}
impl From<StringSeq> for StringOrConst {
    #[inline]
    fn from(node: StringSeq) -> StringOrConst {
        StringOrConst::StringSeq(node)
    }
}
impl AstNode for StringOrConst {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            REF_TERM | STRING_SEQ => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            REF_TERM => Some(StringOrConst::RefTerm(RefTerm { syntax })),
            STRING_SEQ => Some(StringOrConst::StringSeq(StringSeq { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            StringOrConst::RefTerm(it) => &it.syntax,
            StringOrConst::StringSeq(it) => &it.syntax,
        }
    }
}
impl From<CatchHandler> for TryHandler {
    #[inline]
    fn from(node: CatchHandler) -> TryHandler {
        TryHandler::CatchHandler(node)
    }
}
impl From<FinallyHandler> for TryHandler {
    #[inline]
    fn from(node: FinallyHandler) -> TryHandler {
        TryHandler::FinallyHandler(node)
    }
}
impl AstNode for TryHandler {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            CATCH_HANDLER | FINALLY_HANDLER => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            CATCH_HANDLER => Some(TryHandler::CatchHandler(CatchHandler { syntax })),
            FINALLY_HANDLER => Some(TryHandler::FinallyHandler(FinallyHandler { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TryHandler::CatchHandler(it) => &it.syntax,
            TryHandler::FinallyHandler(it) => &it.syntax,
        }
    }
}
impl From<ListType> for TypeKind {
    #[inline]
    fn from(node: ListType) -> TypeKind {
        TypeKind::ListType(node)
    }
}
impl From<RefTerm> for TypeKind {
    #[inline]
    fn from(node: RefTerm) -> TypeKind {
        TypeKind::RefTerm(node)
    }
}
impl From<ScopeType> for TypeKind {
    #[inline]
    fn from(node: ScopeType) -> TypeKind {
        TypeKind::ScopeType(node)
    }
}
impl From<VarType> for TypeKind {
    #[inline]
    fn from(node: VarType) -> TypeKind {
        TypeKind::VarType(node)
    }
}
impl AstNode for TypeKind {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        #[allow(clippy::match_like_matches_macro)]
        match kind {
            LIST_TYPE | REF_TERM | SCOPE_TYPE | VAR_TYPE => true,
            _ => false,
        }
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            LIST_TYPE => Some(TypeKind::ListType(ListType { syntax })),
            REF_TERM => Some(TypeKind::RefTerm(RefTerm { syntax })),
            SCOPE_TYPE => Some(TypeKind::ScopeType(ScopeType { syntax })),
            VAR_TYPE => Some(TypeKind::VarType(VarType { syntax })),
            _ => None,
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TypeKind::ListType(it) => &it.syntax,
            TypeKind::RefTerm(it) => &it.syntax,
            TypeKind::ScopeType(it) => &it.syntax,
            TypeKind::VarType(it) => &it.syntax,
        }
    }
}
impl ast::HasAttributes for AnyHasAttributes {}
impl AstNode for AnyHasAttributes {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ALIAS_DOMAIN
                | BITSIZE_DOMAIN
                | CLASS_FACT_FUNCTOR
                | CLASS_FACT_VAR
                | CLASS_ITEM
                | CLASS_PREDICATE
                | CLASS_PROPERTY
                | CONSTANT
                | CONSTRUCTOR
                | DIGITS_DOMAIN
                | FACT_FUNCTOR
                | FACT_VAR
                | FORMAL_ARG
                | FORMAL_PARAM
                | FUNCTOR
                | IMPLEMENT_ITEM
                | INTERFACE_ITEM
                | PREDICATE
                | PREDICATE_DOMAIN
                | PROPERTY
                | RANGE_DOMAIN
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasAttributes { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AnyHasAttributes {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AnyHasAttributes {}
impl PartialEq for AnyHasAttributes {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AnyHasAttributes {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AnyHasAttributes {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AnyHasAttributes").field("syntax", &self.syntax).finish()
    }
}
impl From<AliasDomain> for AnyHasAttributes {
    #[inline]
    fn from(node: AliasDomain) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<BitsizeDomain> for AnyHasAttributes {
    #[inline]
    fn from(node: BitsizeDomain) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<ClassFactFunctor> for AnyHasAttributes {
    #[inline]
    fn from(node: ClassFactFunctor) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<ClassFactVar> for AnyHasAttributes {
    #[inline]
    fn from(node: ClassFactVar) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<ClassItem> for AnyHasAttributes {
    #[inline]
    fn from(node: ClassItem) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<ClassPredicate> for AnyHasAttributes {
    #[inline]
    fn from(node: ClassPredicate) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<ClassProperty> for AnyHasAttributes {
    #[inline]
    fn from(node: ClassProperty) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<Constant> for AnyHasAttributes {
    #[inline]
    fn from(node: Constant) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<Constructor> for AnyHasAttributes {
    #[inline]
    fn from(node: Constructor) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<DigitsDomain> for AnyHasAttributes {
    #[inline]
    fn from(node: DigitsDomain) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<FactFunctor> for AnyHasAttributes {
    #[inline]
    fn from(node: FactFunctor) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<FactVar> for AnyHasAttributes {
    #[inline]
    fn from(node: FactVar) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<FormalArg> for AnyHasAttributes {
    #[inline]
    fn from(node: FormalArg) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<FormalParam> for AnyHasAttributes {
    #[inline]
    fn from(node: FormalParam) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<Functor> for AnyHasAttributes {
    #[inline]
    fn from(node: Functor) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<ImplementItem> for AnyHasAttributes {
    #[inline]
    fn from(node: ImplementItem) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<InterfaceItem> for AnyHasAttributes {
    #[inline]
    fn from(node: InterfaceItem) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<Predicate> for AnyHasAttributes {
    #[inline]
    fn from(node: Predicate) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<PredicateDomain> for AnyHasAttributes {
    #[inline]
    fn from(node: PredicateDomain) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<Property> for AnyHasAttributes {
    #[inline]
    fn from(node: Property) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl From<RangeDomain> for AnyHasAttributes {
    #[inline]
    fn from(node: RangeDomain) -> AnyHasAttributes {
        AnyHasAttributes { syntax: node.syntax }
    }
}
impl ast::HasClassSections for AnyHasClassSections {}
impl AstNode for AnyHasClassSections {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, CLASS_ITEM | COND_CLASS_SECTION | ELSE_CLASS_SECTION | ELSE_IF_CLASS_SECTION)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasClassSections { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AnyHasClassSections {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AnyHasClassSections {}
impl PartialEq for AnyHasClassSections {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AnyHasClassSections {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AnyHasClassSections {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AnyHasClassSections").field("syntax", &self.syntax).finish()
    }
}
impl From<ClassItem> for AnyHasClassSections {
    #[inline]
    fn from(node: ClassItem) -> AnyHasClassSections {
        AnyHasClassSections { syntax: node.syntax }
    }
}
impl From<CondClassSection> for AnyHasClassSections {
    #[inline]
    fn from(node: CondClassSection) -> AnyHasClassSections {
        AnyHasClassSections { syntax: node.syntax }
    }
}
impl From<ElseClassSection> for AnyHasClassSections {
    #[inline]
    fn from(node: ElseClassSection) -> AnyHasClassSections {
        AnyHasClassSections { syntax: node.syntax }
    }
}
impl From<ElseIfClassSection> for AnyHasClassSections {
    #[inline]
    fn from(node: ElseIfClassSection) -> AnyHasClassSections {
        AnyHasClassSections { syntax: node.syntax }
    }
}
impl ast::HasFormalParamList for AnyHasFormalParamList {}
impl AstNode for AnyHasFormalParamList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, CLASS_FACT_FUNCTOR | FACT_FUNCTOR | PREDICATE_DOMAIN)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasFormalParamList { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AnyHasFormalParamList {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AnyHasFormalParamList {}
impl PartialEq for AnyHasFormalParamList {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AnyHasFormalParamList {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AnyHasFormalParamList {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AnyHasFormalParamList").field("syntax", &self.syntax).finish()
    }
}
impl From<ClassFactFunctor> for AnyHasFormalParamList {
    #[inline]
    fn from(node: ClassFactFunctor) -> AnyHasFormalParamList {
        AnyHasFormalParamList { syntax: node.syntax }
    }
}
impl From<FactFunctor> for AnyHasFormalParamList {
    #[inline]
    fn from(node: FactFunctor) -> AnyHasFormalParamList {
        AnyHasFormalParamList { syntax: node.syntax }
    }
}
impl From<PredicateDomain> for AnyHasFormalParamList {
    #[inline]
    fn from(node: PredicateDomain) -> AnyHasFormalParamList {
        AnyHasFormalParamList { syntax: node.syntax }
    }
}
impl ast::HasImplementSections for AnyHasImplementSections {}
impl AstNode for AnyHasImplementSections {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            COND_IMPLEMENT_SECTION
                | ELSE_IF_IMPLEMENT_SECTION
                | ELSE_IMPLEMENT_SECTION
                | IMPLEMENT_ITEM
                | OBJECT_EXPR
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasImplementSections { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AnyHasImplementSections {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AnyHasImplementSections {}
impl PartialEq for AnyHasImplementSections {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AnyHasImplementSections {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AnyHasImplementSections {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AnyHasImplementSections").field("syntax", &self.syntax).finish()
    }
}
impl From<CondImplementSection> for AnyHasImplementSections {
    #[inline]
    fn from(node: CondImplementSection) -> AnyHasImplementSections {
        AnyHasImplementSections { syntax: node.syntax }
    }
}
impl From<ElseIfImplementSection> for AnyHasImplementSections {
    #[inline]
    fn from(node: ElseIfImplementSection) -> AnyHasImplementSections {
        AnyHasImplementSections { syntax: node.syntax }
    }
}
impl From<ElseImplementSection> for AnyHasImplementSections {
    #[inline]
    fn from(node: ElseImplementSection) -> AnyHasImplementSections {
        AnyHasImplementSections { syntax: node.syntax }
    }
}
impl From<ImplementItem> for AnyHasImplementSections {
    #[inline]
    fn from(node: ImplementItem) -> AnyHasImplementSections {
        AnyHasImplementSections { syntax: node.syntax }
    }
}
impl From<ObjectExpr> for AnyHasImplementSections {
    #[inline]
    fn from(node: ObjectExpr) -> AnyHasImplementSections {
        AnyHasImplementSections { syntax: node.syntax }
    }
}
impl ast::HasInterfaceSections for AnyHasInterfaceSections {}
impl AstNode for AnyHasInterfaceSections {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            COND_INTERFACE_SECTION
                | ELSE_IF_INTERFACE_SECTION
                | ELSE_INTERFACE_SECTION
                | INTERFACE_ITEM
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasInterfaceSections { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AnyHasInterfaceSections {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AnyHasInterfaceSections {}
impl PartialEq for AnyHasInterfaceSections {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AnyHasInterfaceSections {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AnyHasInterfaceSections {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AnyHasInterfaceSections").field("syntax", &self.syntax).finish()
    }
}
impl From<CondInterfaceSection> for AnyHasInterfaceSections {
    #[inline]
    fn from(node: CondInterfaceSection) -> AnyHasInterfaceSections {
        AnyHasInterfaceSections { syntax: node.syntax }
    }
}
impl From<ElseIfInterfaceSection> for AnyHasInterfaceSections {
    #[inline]
    fn from(node: ElseIfInterfaceSection) -> AnyHasInterfaceSections {
        AnyHasInterfaceSections { syntax: node.syntax }
    }
}
impl From<ElseInterfaceSection> for AnyHasInterfaceSections {
    #[inline]
    fn from(node: ElseInterfaceSection) -> AnyHasInterfaceSections {
        AnyHasInterfaceSections { syntax: node.syntax }
    }
}
impl From<InterfaceItem> for AnyHasInterfaceSections {
    #[inline]
    fn from(node: InterfaceItem) -> AnyHasInterfaceSections {
        AnyHasInterfaceSections { syntax: node.syntax }
    }
}
impl ast::HasItems for AnyHasItems {}
impl AstNode for AnyHasItems {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, COND_ITEM | ELSE_IF_ITEM | ELSE_ITEM | SOURCE_FILE)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasItems { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AnyHasItems {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AnyHasItems {}
impl PartialEq for AnyHasItems {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AnyHasItems {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AnyHasItems {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AnyHasItems").field("syntax", &self.syntax).finish()
    }
}
impl From<CondItem> for AnyHasItems {
    #[inline]
    fn from(node: CondItem) -> AnyHasItems {
        AnyHasItems { syntax: node.syntax }
    }
}
impl From<ElseIfItem> for AnyHasItems {
    #[inline]
    fn from(node: ElseIfItem) -> AnyHasItems {
        AnyHasItems { syntax: node.syntax }
    }
}
impl From<ElseItem> for AnyHasItems {
    #[inline]
    fn from(node: ElseItem) -> AnyHasItems {
        AnyHasItems { syntax: node.syntax }
    }
}
impl From<SourceFile> for AnyHasItems {
    #[inline]
    fn from(node: SourceFile) -> AnyHasItems {
        AnyHasItems { syntax: node.syntax }
    }
}
impl ast::HasPredParams for AnyHasPredParams {}
impl AstNode for AnyHasPredParams {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, CLASS_PREDICATE | PREDICATE)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasPredParams { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AnyHasPredParams {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AnyHasPredParams {}
impl PartialEq for AnyHasPredParams {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AnyHasPredParams {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AnyHasPredParams {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AnyHasPredParams").field("syntax", &self.syntax).finish()
    }
}
impl From<ClassPredicate> for AnyHasPredParams {
    #[inline]
    fn from(node: ClassPredicate) -> AnyHasPredParams {
        AnyHasPredParams { syntax: node.syntax }
    }
}
impl From<Predicate> for AnyHasPredParams {
    #[inline]
    fn from(node: Predicate) -> AnyHasPredParams {
        AnyHasPredParams { syntax: node.syntax }
    }
}
impl ast::HasScopeNameDecl for AnyHasScopeNameDecl {}
impl AstNode for AnyHasScopeNameDecl {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            CLASS_ITEM
                | END_CLASS_ITEM
                | END_IMPLEMENT_ITEM
                | END_INTERFACE_ITEM
                | IMPLEMENT_ITEM
                | INTERFACE_ITEM
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasScopeNameDecl { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AnyHasScopeNameDecl {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AnyHasScopeNameDecl {}
impl PartialEq for AnyHasScopeNameDecl {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AnyHasScopeNameDecl {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AnyHasScopeNameDecl {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AnyHasScopeNameDecl").field("syntax", &self.syntax).finish()
    }
}
impl From<ClassItem> for AnyHasScopeNameDecl {
    #[inline]
    fn from(node: ClassItem) -> AnyHasScopeNameDecl {
        AnyHasScopeNameDecl { syntax: node.syntax }
    }
}
impl From<EndClassItem> for AnyHasScopeNameDecl {
    #[inline]
    fn from(node: EndClassItem) -> AnyHasScopeNameDecl {
        AnyHasScopeNameDecl { syntax: node.syntax }
    }
}
impl From<EndImplementItem> for AnyHasScopeNameDecl {
    #[inline]
    fn from(node: EndImplementItem) -> AnyHasScopeNameDecl {
        AnyHasScopeNameDecl { syntax: node.syntax }
    }
}
impl From<EndInterfaceItem> for AnyHasScopeNameDecl {
    #[inline]
    fn from(node: EndInterfaceItem) -> AnyHasScopeNameDecl {
        AnyHasScopeNameDecl { syntax: node.syntax }
    }
}
impl From<ImplementItem> for AnyHasScopeNameDecl {
    #[inline]
    fn from(node: ImplementItem) -> AnyHasScopeNameDecl {
        AnyHasScopeNameDecl { syntax: node.syntax }
    }
}
impl From<InterfaceItem> for AnyHasScopeNameDecl {
    #[inline]
    fn from(node: InterfaceItem) -> AnyHasScopeNameDecl {
        AnyHasScopeNameDecl { syntax: node.syntax }
    }
}
impl ast::HasStringSeq for AnyHasStringSeq {}
impl AstNode for AnyHasStringSeq {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            BIN_INCLUDE
                | ERROR_DIRECTIVE
                | INCLUDE_ITEM
                | MESSAGE_DIRECTIVE
                | OPTIONS_ITEM
                | OR_REQUIRES_DIRECTIVE
                | REQUIRES_DIRECTIVE
                | STRING_INCLUDE
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasStringSeq { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AnyHasStringSeq {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AnyHasStringSeq {}
impl PartialEq for AnyHasStringSeq {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AnyHasStringSeq {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AnyHasStringSeq {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AnyHasStringSeq").field("syntax", &self.syntax).finish()
    }
}
impl From<BinInclude> for AnyHasStringSeq {
    #[inline]
    fn from(node: BinInclude) -> AnyHasStringSeq {
        AnyHasStringSeq { syntax: node.syntax }
    }
}
impl From<ErrorDirective> for AnyHasStringSeq {
    #[inline]
    fn from(node: ErrorDirective) -> AnyHasStringSeq {
        AnyHasStringSeq { syntax: node.syntax }
    }
}
impl From<IncludeItem> for AnyHasStringSeq {
    #[inline]
    fn from(node: IncludeItem) -> AnyHasStringSeq {
        AnyHasStringSeq { syntax: node.syntax }
    }
}
impl From<MessageDirective> for AnyHasStringSeq {
    #[inline]
    fn from(node: MessageDirective) -> AnyHasStringSeq {
        AnyHasStringSeq { syntax: node.syntax }
    }
}
impl From<OptionsItem> for AnyHasStringSeq {
    #[inline]
    fn from(node: OptionsItem) -> AnyHasStringSeq {
        AnyHasStringSeq { syntax: node.syntax }
    }
}
impl From<OrRequiresDirective> for AnyHasStringSeq {
    #[inline]
    fn from(node: OrRequiresDirective) -> AnyHasStringSeq {
        AnyHasStringSeq { syntax: node.syntax }
    }
}
impl From<RequiresDirective> for AnyHasStringSeq {
    #[inline]
    fn from(node: RequiresDirective) -> AnyHasStringSeq {
        AnyHasStringSeq { syntax: node.syntax }
    }
}
impl From<StringInclude> for AnyHasStringSeq {
    #[inline]
    fn from(node: StringInclude) -> AnyHasStringSeq {
        AnyHasStringSeq { syntax: node.syntax }
    }
}
impl ast::HasType for AnyHasType {}
impl AstNode for AnyHasType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ALIAS_DOMAIN
                | CLASS_FACT_VAR
                | CLASS_PROPERTY
                | CONSTANT
                | FACT_VAR
                | FORMAL_ARG
                | FORMAL_PARAM
                | FUNCTOR
                | LIST_TYPE
                | PROPERTY
                | TYPE_ARG
                | TYPE_BOUND
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasType { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl hash::Hash for AnyHasType {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.syntax.hash(state);
    }
}
impl Eq for AnyHasType {}
impl PartialEq for AnyHasType {
    fn eq(&self, other: &Self) -> bool {
        self.syntax == other.syntax
    }
}
impl Clone for AnyHasType {
    fn clone(&self) -> Self {
        Self { syntax: self.syntax.clone() }
    }
}
impl fmt::Debug for AnyHasType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AnyHasType").field("syntax", &self.syntax).finish()
    }
}
impl From<AliasDomain> for AnyHasType {
    #[inline]
    fn from(node: AliasDomain) -> AnyHasType {
        AnyHasType { syntax: node.syntax }
    }
}
impl From<ClassFactVar> for AnyHasType {
    #[inline]
    fn from(node: ClassFactVar) -> AnyHasType {
        AnyHasType { syntax: node.syntax }
    }
}
impl From<ClassProperty> for AnyHasType {
    #[inline]
    fn from(node: ClassProperty) -> AnyHasType {
        AnyHasType { syntax: node.syntax }
    }
}
impl From<Constant> for AnyHasType {
    #[inline]
    fn from(node: Constant) -> AnyHasType {
        AnyHasType { syntax: node.syntax }
    }
}
impl From<FactVar> for AnyHasType {
    #[inline]
    fn from(node: FactVar) -> AnyHasType {
        AnyHasType { syntax: node.syntax }
    }
}
impl From<FormalArg> for AnyHasType {
    #[inline]
    fn from(node: FormalArg) -> AnyHasType {
        AnyHasType { syntax: node.syntax }
    }
}
impl From<FormalParam> for AnyHasType {
    #[inline]
    fn from(node: FormalParam) -> AnyHasType {
        AnyHasType { syntax: node.syntax }
    }
}
impl From<Functor> for AnyHasType {
    #[inline]
    fn from(node: Functor) -> AnyHasType {
        AnyHasType { syntax: node.syntax }
    }
}
impl From<ListType> for AnyHasType {
    #[inline]
    fn from(node: ListType) -> AnyHasType {
        AnyHasType { syntax: node.syntax }
    }
}
impl From<Property> for AnyHasType {
    #[inline]
    fn from(node: Property) -> AnyHasType {
        AnyHasType { syntax: node.syntax }
    }
}
impl From<TypeArg> for AnyHasType {
    #[inline]
    fn from(node: TypeArg) -> AnyHasType {
        AnyHasType { syntax: node.syntax }
    }
}
impl From<TypeBound> for AnyHasType {
    #[inline]
    fn from(node: TypeBound) -> AnyHasType {
        AnyHasType { syntax: node.syntax }
    }
}
impl std::fmt::Display for ApplyArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AtomStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClassFact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClassSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClauseKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Delegate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DomainDef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Fact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FlowArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FlowPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FunctorArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ImplementQualification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ImplementSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InterfaceQualification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InterfaceSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Item {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ItemCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OpenQualification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PredParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RecClassSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RecImplementSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RecInterfaceSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RecItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Resolution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StringOrConst {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryHandler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AccessTerm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AliasDomain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyFlow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ApplyArgs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ApplyTerm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Arity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArityList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssignStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AttributeList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinInclude {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinLiteral {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BitsizeDomain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BitsizeExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallingConvention {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CaseArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CatchHandler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClassFactFunctor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClassFactVar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClassFactsSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClassItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClassPredicate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClassPredicatesSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClassPropertiesSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClassProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClassSections {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Clause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClauseBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClausesSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CondClassSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CondImplementSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CondInterfaceSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CondItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Condition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConsExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Constant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConstantsSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Constructor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConstructorsSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CutStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DelegateSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Delegates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DigitsDomain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DigitsExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Domain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DomainsSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Ellipsis {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseClassSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseIfClassSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseIfImplementSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseIfInterfaceSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseIfItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseIfTerm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseImplementSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseInterfaceSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseTerm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EndClassItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EndForeach {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EndIf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EndImplement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EndImplementItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EndInterfaceItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EndMatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EndTry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ErrorDirective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExportItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Exprs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExternalPredicateResolution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExternallyItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExternallySubject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FactFunctor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FactVar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FactsSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FinallyHandler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FindAllExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Flow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FlowArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FlowDirection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FlowPatternList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForeachStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FormalArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FormalArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FormalParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FormalParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Functor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FunctorArgs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FunctorDomain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FunctorFlow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Generics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GoalItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GuardClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IfTerm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ImplementItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ImplementSections {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IncludeItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InheritsQualifications {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InlineParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InterfaceDelegate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InterfaceItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InterfaceRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InterfaceResolution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InterfaceSections {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IterStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for KeywordArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LambdaExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LinkName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListFlow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MessageDirective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Mode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Namespace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamespaceItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamespacePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NumericDomain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NumericLiteral {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ObjectExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OpenQualifications {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OptionsItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OrRequiresDirective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenTerm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathSegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PredProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PredPropertyList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Predicate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PredicateDelegate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PredicateDomain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PredicateResolution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PredicatesFromSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PredicatesSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PropertiesFromSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PropertiesSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Property {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RangeDomain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RangeExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RefTerm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RelationStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RequiresDirective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Resolutions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ResolveSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ReturnParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ScopeNameDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ScopeParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ScopeRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ScopeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StringInclude {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StringPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StringSeq {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SupportsQualifications {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeBound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeBounds {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VarExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VarType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}

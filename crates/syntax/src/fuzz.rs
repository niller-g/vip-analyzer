//! Some infrastructure for fuzzy testing.

use crate::SourceFile;

pub fn check_parser(text: &str) {
    assert_eq!(text, SourceFile::parse(text).syntax_node().to_string());
}

#[test]
fn from_bytes() {
    // `DATA` is some arbitrary bytes generated by the fuzzer.
    // This test is only here to conveniently run specific fuzz cases.
    const DATA: &[u8] = &[
        127, 102, 114, 101, 110, 48, 92, 10, 0, 90, 0, 0, 0, 0, 0, 0, 0, 115, 0, 32, 0, 100, 101,
        35, 0, 0, 123, 0, 35, 33, 0, 0, 123, 0, 115, 58, 0, 44, 99, 108, 97, 115, 115, 32, 100,
        111, 109, 97, 105, 110, 115, 32, 121, 40, 42, 43, 91, 44, 110, 42, 78, 102, 83, 78, 63,
        105, 32, 12, 43, 91, 44, 110, 42, 78, 101, 91, 35, 74, 44, 93, 105, 102, 52, 58, 0, 44, 93,
        108, 97, 115, 115, 32, 121, 40, 42, 43, 0, 83, 78, 105, 119, 110, 115, 32, 121, 40, 42, 43,
        91, 44, 110, 42, 71, 102, 44, 93, 105, 102, 50, 115, 1, 25,
    ];
    if let Ok(text) = std::str::from_utf8(DATA) {
        // println!("{}", text);
        check_parser(text);
    }
}

#[test]
fn from_text() {
    // `TEXT` is some arbitrary bytes generated by the fuzzer.
    // This test is only here to conveniently run specific fuzz cases.
    const TEXT: &str = r#"erguardfa/a class
n:facts-o
namesp(/if=99/#/#i/a class:factasme-f-//spa/if=;9/#/a class
n:facts-o
names.p//if=99/#/#i/a class:factasme-f-//space
/ace
m/m"#;

    check_parser(TEXT);
}

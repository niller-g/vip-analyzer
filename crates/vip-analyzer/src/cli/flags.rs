//! Grammar for the command-line arguments.

use std::{path::PathBuf, str::FromStr};

xflags::xflags! {
    src "./src/cli/flags.rs"

    /// LSP server for the Rust programming language.
    ///
    /// Subcommands and their flags do not provide any stability guarantees and may be removed or
    /// changed without notice. Top-level flags that are not marked as [Unstable] provide
    /// backwards-compatibility and may be relied on.
    cmd vip-analyzer {
        /// Log to the specified file instead of stderr.
        optional --log-file path: PathBuf

        /// [Unstable] Wait until a debugger is attached to (requires debug build).
        optional --wait-dbg

        optional --vipfmt-path path: PathBuf

        default cmd lsp-server {
            /// Print version.
            optional -V, --version

            /// Dump a LSP config JSON schema.
            optional --print-config-schema
        }
    }
}

// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct VipAnalyzer {
    pub log_file: Option<PathBuf>,
    pub wait_dbg: bool,
    pub vipfmt_path: Option<PathBuf>,
    pub subcommand: VipAnalyzerCmd,
}

#[derive(Debug)]
pub enum VipAnalyzerCmd {
    LspServer(LspServer),
}

#[derive(Debug)]
pub struct LspServer {
    pub version: bool,
    pub print_config_schema: bool,
}

impl VipAnalyzer {
    #[allow(dead_code)]
    pub fn from_env_or_exit() -> Self {
        Self::from_env_or_exit_()
    }

    #[allow(dead_code)]
    pub fn from_env() -> xflags::Result<Self> {
        Self::from_env_()
    }

    #[allow(dead_code)]
    pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
        Self::from_vec_(args)
    }
}
// generated end

#[derive(Debug, PartialEq, Eq)]
pub enum OutputFormat {
    Csv,
}

impl FromStr for OutputFormat {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "csv" => Ok(Self::Csv),
            _ => Err(format!("unknown output format `{s}`")),
        }
    }
}

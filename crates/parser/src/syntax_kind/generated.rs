//! Generated by `cargo xtask codegen grammar`, do not edit by hand.

#![expect(non_camel_case_types)]
#[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
#[derive(Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    COMMA,
    SEMICOLON,
    DOT,
    DOTDOT,
    DOTDOTDOT,
    L_PAREN,
    R_PAREN,
    L_CURLY,
    R_CURLY,
    L_BRACK,
    R_BRACK,
    COLONEQ,
    ARROW,
    STAR,
    STARSTAR,
    AT,
    CARET,
    CARETCARET,
    MINUS,
    MINUSMINUS,
    PLUS,
    PLUSPLUS,
    SLASH,
    BACKSLASH,
    COLON,
    COLONCOLON,
    COLONDASH,
    DOLLAR,
    PIPE,
    PIPEPIPE,
    EQ,
    EQEQ,
    EXCL,
    LT,
    GT,
    LTEQ,
    GTEQ,
    LTGT,
    GTLT,
    SHL,
    SHR,
    TILDE,
    TILDETILDE,
    ALIGN_KW,
    AND_KW,
    ANYFLOW_KW,
    AS_KW,
    BITSIZE_KW,
    CASE_KW,
    CATCH_KW,
    CLASS_KW,
    CLAUSES_KW,
    CONSTANTS_KW,
    CONSTRUCTORS_KW,
    DELEGATE_KW,
    DETERM_KW,
    DIGITS_KW,
    DIV_KW,
    DO_KW,
    DOMAINS_KW,
    ELSE_KW,
    ELSEIF_KW,
    END_KW,
    ERRONEOUS_KW,
    EXTERNALLY_KW,
    FACTS_KW,
    FAILURE_KW,
    FINALLY_KW,
    FOREACH_KW,
    FROM_KW,
    GOAL_KW,
    GUARD_KW,
    IF_KW,
    IMPLEMENT_KW,
    INHERITS_KW,
    INTERFACE_KW,
    MATCH_KW,
    MOD_KW,
    MONITOR_KW,
    MULTI_KW,
    NAMESPACE_KW,
    NONDETERM_KW,
    OPEN_KW,
    OR_KW,
    ORELSE_KW,
    OTHERWISE_KW,
    PREDICATES_KW,
    PROCEDURE_KW,
    PROPERTIES_KW,
    QUOT_KW,
    REM_KW,
    RESOLVE_KW,
    SINGLE_KW,
    SUPPORTS_KW,
    SUSPENDING_KW,
    THEN_KW,
    TRY_KW,
    WHERE_KW,
    I_KW,
    IN_KW,
    LANGUAGE_KW,
    O_KW,
    TO_KW,
    HASHBININCLUDE,
    HASHELSE,
    HASHELSEIF,
    HASHENDIF,
    HASHERROR,
    HASHEXPORT,
    HASHEXTERNALLY,
    HASHFROM,
    HASHIF,
    HASHINCLUDE,
    HASHMESSAGE,
    HASHOPTIONS,
    HASHORREQUIRES,
    HASHREQUIRES,
    HASHSTRINGINCLUDE,
    HASHTHEN,
    COMMENT,
    ERROR,
    FLOAT_NUMBER,
    IDENT,
    INT_NUMBER,
    STRING,
    VAR,
    WHITESPACE,
    #[doc(hidden)]
    __LAST_TOKEN,
    ACCESS_TERM,
    ALIAS_DOMAIN,
    ANY_FLOW,
    APPLY_ARGS,
    APPLY_TERM,
    ARITY,
    ARITY_LIST,
    ASSIGN_STMT,
    ATTRIBUTE_LIST,
    BIN_EXPR,
    BIN_INCLUDE,
    BIN_LITERAL,
    BIN_STMT,
    BITSIZE_DOMAIN,
    BITSIZE_EXPR,
    CALLING_CONVENTION,
    CASE_ARM,
    CATCH_HANDLER,
    CLASS_FACTS_SECTION,
    CLASS_FACT_FUNCTOR,
    CLASS_FACT_VAR,
    CLASS_ITEM,
    CLASS_PREDICATE,
    CLASS_PREDICATES_SECTION,
    CLASS_PROPERTIES_SECTION,
    CLASS_PROPERTY,
    CLASS_SECTIONS,
    CLAUSE,
    CLAUSES_SECTION,
    CLAUSE_BODY,
    CONDITION,
    COND_CLASS_SECTION,
    COND_IMPLEMENT_SECTION,
    COND_INTERFACE_SECTION,
    COND_ITEM,
    CONSTANT,
    CONSTANTS_SECTION,
    CONSTRUCTOR,
    CONSTRUCTORS_SECTION,
    CONS_EXPR,
    CUT_STMT,
    DELEGATES,
    DELEGATE_SECTION,
    DIGITS_DOMAIN,
    DIGITS_EXPR,
    DOMAIN,
    DOMAINS_SECTION,
    ELLIPSIS,
    ELSE_CLASS_SECTION,
    ELSE_IF_CLASS_SECTION,
    ELSE_IF_IMPLEMENT_SECTION,
    ELSE_IF_INTERFACE_SECTION,
    ELSE_IF_ITEM,
    ELSE_IF_TERM,
    ELSE_IMPLEMENT_SECTION,
    ELSE_INTERFACE_SECTION,
    ELSE_ITEM,
    ELSE_TERM,
    END_CLASS_ITEM,
    END_FOREACH,
    END_IF,
    END_IMPLEMENT,
    END_IMPLEMENT_ITEM,
    END_INTERFACE_ITEM,
    END_MATCH,
    END_TRY,
    ERROR_DIRECTIVE,
    EXPORT_ITEM,
    EXPRS,
    EXTERNALLY_ITEM,
    EXTERNALLY_SUBJECT,
    EXTERNAL_PREDICATE_RESOLUTION,
    FACTS_SECTION,
    FACT_FUNCTOR,
    FACT_VAR,
    FINALLY_HANDLER,
    FIND_ALL_EXPR,
    FLOW,
    FLOW_ARG_LIST,
    FLOW_DIRECTION,
    FLOW_PATTERN_LIST,
    FOREACH_STMT,
    FORMAL_ARG,
    FORMAL_ARG_LIST,
    FORMAL_PARAM,
    FORMAL_PARAM_LIST,
    FUNCTOR,
    FUNCTOR_ARGS,
    FUNCTOR_DOMAIN,
    FUNCTOR_FLOW,
    GENERICS,
    GOAL_ITEM,
    GUARD_CLAUSE,
    IF_TERM,
    IMPLEMENT_ITEM,
    IMPLEMENT_SECTIONS,
    INCLUDE_ITEM,
    INHERITS_QUALIFICATIONS,
    INLINE_PARAMS,
    INTERFACE_DELEGATE,
    INTERFACE_ITEM,
    INTERFACE_REF,
    INTERFACE_RESOLUTION,
    INTERFACE_SECTIONS,
    IN_STMT,
    ITER_STMT,
    KEYWORD_ARG,
    LAMBDA_EXPR,
    LINK_NAME,
    LIST_EXPR,
    LIST_FLOW,
    LIST_TYPE,
    MATCH_STMT,
    MESSAGE_DIRECTIVE,
    MODE,
    NAMESPACE,
    NAMESPACE_ITEM,
    NAMESPACE_PATH,
    NUMERIC_DOMAIN,
    NUMERIC_LITERAL,
    OBJECT_EXPR,
    OPEN_QUALIFICATIONS,
    OPTIONS_ITEM,
    OR_REQUIRES_DIRECTIVE,
    PAREN_TERM,
    PATH_SEGMENT,
    PREDICATE,
    PREDICATES_FROM_SECTION,
    PREDICATES_SECTION,
    PREDICATE_DELEGATE,
    PREDICATE_DOMAIN,
    PREDICATE_RESOLUTION,
    PRED_PROPERTY,
    PRED_PROPERTY_LIST,
    PREFIX_EXPR,
    PROPERTIES_FROM_SECTION,
    PROPERTIES_SECTION,
    PROPERTY,
    RANGE_DOMAIN,
    RANGE_EXPR,
    REF_TERM,
    RELATION_STMT,
    REQUIRES_DIRECTIVE,
    RESOLUTIONS,
    RESOLVE_SECTION,
    RETURN_PARAM,
    SCOPE_NAME_DECL,
    SCOPE_PARAMS,
    SCOPE_REF,
    SCOPE_TYPE,
    SOURCE_FILE,
    STRING_INCLUDE,
    STRING_PART,
    STRING_SEQ,
    SUPPORTS_QUALIFICATIONS,
    TRY_STMT,
    TYPE,
    TYPE_ARG,
    TYPE_BOUND,
    TYPE_BOUNDS,
    VAR_EXPR,
    VAR_TYPE,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub const fn text(self) -> &'static str {
        match self {
            TOMBSTONE
            | EOF
            | __LAST
            | __LAST_TOKEN
            | ACCESS_TERM
            | ALIAS_DOMAIN
            | ANY_FLOW
            | APPLY_ARGS
            | APPLY_TERM
            | ARITY
            | ARITY_LIST
            | ASSIGN_STMT
            | ATTRIBUTE_LIST
            | BIN_EXPR
            | BIN_INCLUDE
            | BIN_LITERAL
            | BIN_STMT
            | BITSIZE_DOMAIN
            | BITSIZE_EXPR
            | CALLING_CONVENTION
            | CASE_ARM
            | CATCH_HANDLER
            | CLASS_FACTS_SECTION
            | CLASS_FACT_FUNCTOR
            | CLASS_FACT_VAR
            | CLASS_ITEM
            | CLASS_PREDICATE
            | CLASS_PREDICATES_SECTION
            | CLASS_PROPERTIES_SECTION
            | CLASS_PROPERTY
            | CLASS_SECTIONS
            | CLAUSE
            | CLAUSES_SECTION
            | CLAUSE_BODY
            | CONDITION
            | COND_CLASS_SECTION
            | COND_IMPLEMENT_SECTION
            | COND_INTERFACE_SECTION
            | COND_ITEM
            | CONSTANT
            | CONSTANTS_SECTION
            | CONSTRUCTOR
            | CONSTRUCTORS_SECTION
            | CONS_EXPR
            | CUT_STMT
            | DELEGATES
            | DELEGATE_SECTION
            | DIGITS_DOMAIN
            | DIGITS_EXPR
            | DOMAIN
            | DOMAINS_SECTION
            | ELLIPSIS
            | ELSE_CLASS_SECTION
            | ELSE_IF_CLASS_SECTION
            | ELSE_IF_IMPLEMENT_SECTION
            | ELSE_IF_INTERFACE_SECTION
            | ELSE_IF_ITEM
            | ELSE_IF_TERM
            | ELSE_IMPLEMENT_SECTION
            | ELSE_INTERFACE_SECTION
            | ELSE_ITEM
            | ELSE_TERM
            | END_CLASS_ITEM
            | END_FOREACH
            | END_IF
            | END_IMPLEMENT
            | END_IMPLEMENT_ITEM
            | END_INTERFACE_ITEM
            | END_MATCH
            | END_TRY
            | ERROR_DIRECTIVE
            | EXPORT_ITEM
            | EXPRS
            | EXTERNALLY_ITEM
            | EXTERNALLY_SUBJECT
            | EXTERNAL_PREDICATE_RESOLUTION
            | FACTS_SECTION
            | FACT_FUNCTOR
            | FACT_VAR
            | FINALLY_HANDLER
            | FIND_ALL_EXPR
            | FLOW
            | FLOW_ARG_LIST
            | FLOW_DIRECTION
            | FLOW_PATTERN_LIST
            | FOREACH_STMT
            | FORMAL_ARG
            | FORMAL_ARG_LIST
            | FORMAL_PARAM
            | FORMAL_PARAM_LIST
            | FUNCTOR
            | FUNCTOR_ARGS
            | FUNCTOR_DOMAIN
            | FUNCTOR_FLOW
            | GENERICS
            | GOAL_ITEM
            | GUARD_CLAUSE
            | IF_TERM
            | IMPLEMENT_ITEM
            | IMPLEMENT_SECTIONS
            | INCLUDE_ITEM
            | INHERITS_QUALIFICATIONS
            | INLINE_PARAMS
            | INTERFACE_DELEGATE
            | INTERFACE_ITEM
            | INTERFACE_REF
            | INTERFACE_RESOLUTION
            | INTERFACE_SECTIONS
            | IN_STMT
            | ITER_STMT
            | KEYWORD_ARG
            | LAMBDA_EXPR
            | LINK_NAME
            | LIST_EXPR
            | LIST_FLOW
            | LIST_TYPE
            | MATCH_STMT
            | MESSAGE_DIRECTIVE
            | MODE
            | NAMESPACE
            | NAMESPACE_ITEM
            | NAMESPACE_PATH
            | NUMERIC_DOMAIN
            | NUMERIC_LITERAL
            | OBJECT_EXPR
            | OPEN_QUALIFICATIONS
            | OPTIONS_ITEM
            | OR_REQUIRES_DIRECTIVE
            | PAREN_TERM
            | PATH_SEGMENT
            | PREDICATE
            | PREDICATES_FROM_SECTION
            | PREDICATES_SECTION
            | PREDICATE_DELEGATE
            | PREDICATE_DOMAIN
            | PREDICATE_RESOLUTION
            | PRED_PROPERTY
            | PRED_PROPERTY_LIST
            | PREFIX_EXPR
            | PROPERTIES_FROM_SECTION
            | PROPERTIES_SECTION
            | PROPERTY
            | RANGE_DOMAIN
            | RANGE_EXPR
            | REF_TERM
            | RELATION_STMT
            | REQUIRES_DIRECTIVE
            | RESOLUTIONS
            | RESOLVE_SECTION
            | RETURN_PARAM
            | SCOPE_NAME_DECL
            | SCOPE_PARAMS
            | SCOPE_REF
            | SCOPE_TYPE
            | SOURCE_FILE
            | STRING_INCLUDE
            | STRING_PART
            | STRING_SEQ
            | SUPPORTS_QUALIFICATIONS
            | TRY_STMT
            | TYPE
            | TYPE_ARG
            | TYPE_BOUND
            | TYPE_BOUNDS
            | VAR_EXPR
            | VAR_TYPE
            | COMMENT
            | ERROR
            | FLOAT_NUMBER
            | IDENT
            | INT_NUMBER
            | STRING
            | VAR
            | WHITESPACE => panic!("no text for these `SyntaxKind`s"),
            COMMA => ",",
            SEMICOLON => ";",
            DOT => ".",
            DOTDOT => "..",
            DOTDOTDOT => "...",
            L_PAREN => "(",
            R_PAREN => ")",
            L_CURLY => "{",
            R_CURLY => "}",
            L_BRACK => "[",
            R_BRACK => "]",
            COLONEQ => ":=",
            ARROW => "->",
            STAR => "*",
            STARSTAR => "**",
            AT => "@",
            CARET => "^",
            CARETCARET => "^^",
            MINUS => "-",
            MINUSMINUS => "--",
            PLUS => "+",
            PLUSPLUS => "++",
            SLASH => "/",
            BACKSLASH => "\\",
            COLON => ":",
            COLONCOLON => "::",
            COLONDASH => ":-",
            DOLLAR => "$",
            PIPE => "|",
            PIPEPIPE => "||",
            EQ => "=",
            EQEQ => "==",
            EXCL => "!",
            LT => "<",
            GT => ">",
            LTEQ => "<=",
            GTEQ => ">=",
            LTGT => "<>",
            GTLT => "><",
            SHL => "<<",
            SHR => ">>",
            TILDE => "~",
            TILDETILDE => "~~",
            ALIGN_KW => "align",
            AND_KW => "and",
            ANYFLOW_KW => "anyflow",
            AS_KW => "as",
            BITSIZE_KW => "bitsize",
            CASE_KW => "case",
            CATCH_KW => "catch",
            CLASS_KW => "class",
            CLAUSES_KW => "clauses",
            CONSTANTS_KW => "constants",
            CONSTRUCTORS_KW => "constructors",
            DELEGATE_KW => "delegate",
            DETERM_KW => "determ",
            DIGITS_KW => "digits",
            DIV_KW => "div",
            DO_KW => "do",
            DOMAINS_KW => "domains",
            ELSE_KW => "else",
            ELSEIF_KW => "elseif",
            END_KW => "end",
            ERRONEOUS_KW => "erroneous",
            EXTERNALLY_KW => "externally",
            FACTS_KW => "facts",
            FAILURE_KW => "failure",
            FINALLY_KW => "finally",
            FOREACH_KW => "foreach",
            FROM_KW => "from",
            GOAL_KW => "goal",
            GUARD_KW => "guard",
            IF_KW => "if",
            IMPLEMENT_KW => "implement",
            INHERITS_KW => "inherits",
            INTERFACE_KW => "interface",
            MATCH_KW => "match",
            MOD_KW => "mod",
            MONITOR_KW => "monitor",
            MULTI_KW => "multi",
            NAMESPACE_KW => "namespace",
            NONDETERM_KW => "nondeterm",
            OPEN_KW => "open",
            OR_KW => "or",
            ORELSE_KW => "orelse",
            OTHERWISE_KW => "otherwise",
            PREDICATES_KW => "predicates",
            PROCEDURE_KW => "procedure",
            PROPERTIES_KW => "properties",
            QUOT_KW => "quot",
            REM_KW => "rem",
            RESOLVE_KW => "resolve",
            SINGLE_KW => "single",
            SUPPORTS_KW => "supports",
            SUSPENDING_KW => "suspending",
            THEN_KW => "then",
            TRY_KW => "try",
            WHERE_KW => "where",
            I_KW => "i",
            IN_KW => "in",
            LANGUAGE_KW => "language",
            O_KW => "o",
            TO_KW => "to",
            HASHBININCLUDE => "#bininclude",
            HASHELSE => "#else",
            HASHELSEIF => "#elseif",
            HASHENDIF => "#endif",
            HASHERROR => "#error",
            HASHEXPORT => "#export",
            HASHEXTERNALLY => "#externally",
            HASHFROM => "#from",
            HASHIF => "#if",
            HASHINCLUDE => "#include",
            HASHMESSAGE => "#message",
            HASHOPTIONS => "#options",
            HASHORREQUIRES => "#orrequires",
            HASHREQUIRES => "#requires",
            HASHSTRINGINCLUDE => "#stringinclude",
            HASHTHEN => "#then",
        }
    }
    #[doc = r" Checks whether this syntax kind is a strict or weak keyword."]
    pub fn is_strict_keyword(self) -> bool {
        matches!(
            self,
            ALIGN_KW
                | AND_KW
                | ANYFLOW_KW
                | AS_KW
                | BITSIZE_KW
                | CASE_KW
                | CATCH_KW
                | CLASS_KW
                | CLAUSES_KW
                | CONSTANTS_KW
                | CONSTRUCTORS_KW
                | DELEGATE_KW
                | DETERM_KW
                | DIGITS_KW
                | DIV_KW
                | DO_KW
                | DOMAINS_KW
                | ELSE_KW
                | ELSEIF_KW
                | END_KW
                | ERRONEOUS_KW
                | EXTERNALLY_KW
                | FACTS_KW
                | FAILURE_KW
                | FINALLY_KW
                | FOREACH_KW
                | FROM_KW
                | GOAL_KW
                | GUARD_KW
                | IF_KW
                | IMPLEMENT_KW
                | INHERITS_KW
                | INTERFACE_KW
                | MATCH_KW
                | MOD_KW
                | MONITOR_KW
                | MULTI_KW
                | NAMESPACE_KW
                | NONDETERM_KW
                | OPEN_KW
                | OR_KW
                | ORELSE_KW
                | OTHERWISE_KW
                | PREDICATES_KW
                | PROCEDURE_KW
                | PROPERTIES_KW
                | QUOT_KW
                | REM_KW
                | RESOLVE_KW
                | SINGLE_KW
                | SUPPORTS_KW
                | SUSPENDING_KW
                | THEN_KW
                | TRY_KW
                | WHERE_KW
        )
    }
    #[doc = r" Checks whether this syntax kind is a contextual keyword."]
    #[doc = r" Contextual keywords are identifiers that are considered keywords only in certain contexts."]
    pub fn is_contextual_keyword(self) -> bool {
        matches!(self, I_KW | IN_KW | LANGUAGE_KW | O_KW | TO_KW)
    }
    #[doc = r" Checks whether this syntax kind is a keyword (both strict and contextual)."]
    pub fn is_keyword(self) -> bool {
        self.is_strict_keyword() || self.is_contextual_keyword()
    }
    pub fn is_directive(self) -> bool {
        matches!(
            self,
            HASHBININCLUDE
                | HASHELSE
                | HASHELSEIF
                | HASHENDIF
                | HASHERROR
                | HASHEXPORT
                | HASHEXTERNALLY
                | HASHFROM
                | HASHIF
                | HASHINCLUDE
                | HASHMESSAGE
                | HASHOPTIONS
                | HASHORREQUIRES
                | HASHREQUIRES
                | HASHSTRINGINCLUDE
                | HASHTHEN
        )
    }
    pub fn is_punct(self) -> bool {
        matches!(
            self,
            COMMA
                | SEMICOLON
                | DOT
                | DOTDOT
                | DOTDOTDOT
                | L_PAREN
                | R_PAREN
                | L_CURLY
                | R_CURLY
                | L_BRACK
                | R_BRACK
                | COLONEQ
                | ARROW
                | STAR
                | STARSTAR
                | AT
                | CARET
                | CARETCARET
                | MINUS
                | MINUSMINUS
                | PLUS
                | PLUSPLUS
                | SLASH
                | BACKSLASH
                | COLON
                | COLONCOLON
                | COLONDASH
                | DOLLAR
                | PIPE
                | PIPEPIPE
                | EQ
                | EQEQ
                | EXCL
                | LT
                | GT
                | LTEQ
                | GTEQ
                | LTGT
                | GTLT
                | SHL
                | SHR
                | TILDE
                | TILDETILDE
        )
    }
    #[doc = r" Try to build a strict keyword from a string."]
    pub fn from_strict_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "align" => ALIGN_KW,
            "and" => AND_KW,
            "anyflow" => ANYFLOW_KW,
            "as" => AS_KW,
            "bitsize" => BITSIZE_KW,
            "case" => CASE_KW,
            "catch" => CATCH_KW,
            "class" => CLASS_KW,
            "clauses" => CLAUSES_KW,
            "constants" => CONSTANTS_KW,
            "constructors" => CONSTRUCTORS_KW,
            "delegate" => DELEGATE_KW,
            "determ" => DETERM_KW,
            "digits" => DIGITS_KW,
            "div" => DIV_KW,
            "do" => DO_KW,
            "domains" => DOMAINS_KW,
            "else" => ELSE_KW,
            "elseif" => ELSEIF_KW,
            "end" => END_KW,
            "erroneous" => ERRONEOUS_KW,
            "externally" => EXTERNALLY_KW,
            "facts" => FACTS_KW,
            "failure" => FAILURE_KW,
            "finally" => FINALLY_KW,
            "foreach" => FOREACH_KW,
            "from" => FROM_KW,
            "goal" => GOAL_KW,
            "guard" => GUARD_KW,
            "if" => IF_KW,
            "implement" => IMPLEMENT_KW,
            "inherits" => INHERITS_KW,
            "interface" => INTERFACE_KW,
            "match" => MATCH_KW,
            "mod" => MOD_KW,
            "monitor" => MONITOR_KW,
            "multi" => MULTI_KW,
            "namespace" => NAMESPACE_KW,
            "nondeterm" => NONDETERM_KW,
            "open" => OPEN_KW,
            "or" => OR_KW,
            "orelse" => ORELSE_KW,
            "otherwise" => OTHERWISE_KW,
            "predicates" => PREDICATES_KW,
            "procedure" => PROCEDURE_KW,
            "properties" => PROPERTIES_KW,
            "quot" => QUOT_KW,
            "rem" => REM_KW,
            "resolve" => RESOLVE_KW,
            "single" => SINGLE_KW,
            "supports" => SUPPORTS_KW,
            "suspending" => SUSPENDING_KW,
            "then" => THEN_KW,
            "try" => TRY_KW,
            "where" => WHERE_KW,
            _ => return None,
        };
        Some(kw)
    }
    #[doc = r" Try to build a contextual keyword from a string."]
    pub fn from_contextual_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "i" => I_KW,
            "in" => IN_KW,
            "language" => LANGUAGE_KW,
            "o" => O_KW,
            "to" => TO_KW,
            _ => return None,
        };
        Some(kw)
    }
    #[doc = r" Try to build a keyword (both strict and contextual) from a string."]
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        Self::from_strict_keyword(ident).or_else(|| Self::from_contextual_keyword(ident))
    }
    pub fn from_directive(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "#bininclude" => HASHBININCLUDE,
            "#else" => HASHELSE,
            "#elseif" => HASHELSEIF,
            "#endif" => HASHENDIF,
            "#error" => HASHERROR,
            "#export" => HASHEXPORT,
            "#externally" => HASHEXTERNALLY,
            "#from" => HASHFROM,
            "#if" => HASHIF,
            "#include" => HASHINCLUDE,
            "#message" => HASHMESSAGE,
            "#options" => HASHOPTIONS,
            "#orrequires" => HASHORREQUIRES,
            "#requires" => HASHREQUIRES,
            "#stringinclude" => HASHSTRINGINCLUDE,
            "#then" => HASHTHEN,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            ',' => COMMA,
            ';' => SEMICOLON,
            '.' => DOT,
            '(' => L_PAREN,
            ')' => R_PAREN,
            '{' => L_CURLY,
            '}' => R_CURLY,
            '[' => L_BRACK,
            ']' => R_BRACK,
            '*' => STAR,
            '@' => AT,
            '^' => CARET,
            '-' => MINUS,
            '+' => PLUS,
            '/' => SLASH,
            '\\' => BACKSLASH,
            ':' => COLON,
            '$' => DOLLAR,
            '|' => PIPE,
            '=' => EQ,
            '!' => EXCL,
            '<' => LT,
            '>' => GT,
            '~' => TILDE,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T_ { [,] => { $ crate :: SyntaxKind :: COMMA } ; [;] => { $ crate :: SyntaxKind :: SEMICOLON } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [..] => { $ crate :: SyntaxKind :: DOTDOT } ; [...] => { $ crate :: SyntaxKind :: DOTDOTDOT } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: SyntaxKind :: R_CURLY } ; ['['] => { $ crate :: SyntaxKind :: L_BRACK } ; [']'] => { $ crate :: SyntaxKind :: R_BRACK } ; [:=] => { $ crate :: SyntaxKind :: COLONEQ } ; [->] => { $ crate :: SyntaxKind :: ARROW } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [**] => { $ crate :: SyntaxKind :: STARSTAR } ; [@] => { $ crate :: SyntaxKind :: AT } ; [^] => { $ crate :: SyntaxKind :: CARET } ; [^^] => { $ crate :: SyntaxKind :: CARETCARET } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [--] => { $ crate :: SyntaxKind :: MINUSMINUS } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [++] => { $ crate :: SyntaxKind :: PLUSPLUS } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; ['\\'] => { $ crate :: SyntaxKind :: BACKSLASH } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [::] => { $ crate :: SyntaxKind :: COLONCOLON } ; [:-] => { $ crate :: SyntaxKind :: COLONDASH } ; [$] => { $ crate :: SyntaxKind :: DOLLAR } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [||] => { $ crate :: SyntaxKind :: PIPEPIPE } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [==] => { $ crate :: SyntaxKind :: EQEQ } ; [!] => { $ crate :: SyntaxKind :: EXCL } ; [<] => { $ crate :: SyntaxKind :: LT } ; [>] => { $ crate :: SyntaxKind :: GT } ; [<=] => { $ crate :: SyntaxKind :: LTEQ } ; [>=] => { $ crate :: SyntaxKind :: GTEQ } ; [<>] => { $ crate :: SyntaxKind :: LTGT } ; [><] => { $ crate :: SyntaxKind :: GTLT } ; [<<] => { $ crate :: SyntaxKind :: SHL } ; [>>] => { $ crate :: SyntaxKind :: SHR } ; [~] => { $ crate :: SyntaxKind :: TILDE } ; [~~] => { $ crate :: SyntaxKind :: TILDETILDE } ; [align] => { $ crate :: SyntaxKind :: ALIGN_KW } ; [and] => { $ crate :: SyntaxKind :: AND_KW } ; [anyflow] => { $ crate :: SyntaxKind :: ANYFLOW_KW } ; [as] => { $ crate :: SyntaxKind :: AS_KW } ; [bitsize] => { $ crate :: SyntaxKind :: BITSIZE_KW } ; [case] => { $ crate :: SyntaxKind :: CASE_KW } ; [catch] => { $ crate :: SyntaxKind :: CATCH_KW } ; [class] => { $ crate :: SyntaxKind :: CLASS_KW } ; [clauses] => { $ crate :: SyntaxKind :: CLAUSES_KW } ; [constants] => { $ crate :: SyntaxKind :: CONSTANTS_KW } ; [constructors] => { $ crate :: SyntaxKind :: CONSTRUCTORS_KW } ; [delegate] => { $ crate :: SyntaxKind :: DELEGATE_KW } ; [determ] => { $ crate :: SyntaxKind :: DETERM_KW } ; [digits] => { $ crate :: SyntaxKind :: DIGITS_KW } ; [div] => { $ crate :: SyntaxKind :: DIV_KW } ; [do] => { $ crate :: SyntaxKind :: DO_KW } ; [domains] => { $ crate :: SyntaxKind :: DOMAINS_KW } ; [else] => { $ crate :: SyntaxKind :: ELSE_KW } ; [elseif] => { $ crate :: SyntaxKind :: ELSEIF_KW } ; [end] => { $ crate :: SyntaxKind :: END_KW } ; [erroneous] => { $ crate :: SyntaxKind :: ERRONEOUS_KW } ; [externally] => { $ crate :: SyntaxKind :: EXTERNALLY_KW } ; [facts] => { $ crate :: SyntaxKind :: FACTS_KW } ; [failure] => { $ crate :: SyntaxKind :: FAILURE_KW } ; [finally] => { $ crate :: SyntaxKind :: FINALLY_KW } ; [foreach] => { $ crate :: SyntaxKind :: FOREACH_KW } ; [from] => { $ crate :: SyntaxKind :: FROM_KW } ; [goal] => { $ crate :: SyntaxKind :: GOAL_KW } ; [guard] => { $ crate :: SyntaxKind :: GUARD_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [implement] => { $ crate :: SyntaxKind :: IMPLEMENT_KW } ; [inherits] => { $ crate :: SyntaxKind :: INHERITS_KW } ; [interface] => { $ crate :: SyntaxKind :: INTERFACE_KW } ; [match] => { $ crate :: SyntaxKind :: MATCH_KW } ; [mod] => { $ crate :: SyntaxKind :: MOD_KW } ; [monitor] => { $ crate :: SyntaxKind :: MONITOR_KW } ; [multi] => { $ crate :: SyntaxKind :: MULTI_KW } ; [namespace] => { $ crate :: SyntaxKind :: NAMESPACE_KW } ; [nondeterm] => { $ crate :: SyntaxKind :: NONDETERM_KW } ; [open] => { $ crate :: SyntaxKind :: OPEN_KW } ; [or] => { $ crate :: SyntaxKind :: OR_KW } ; [orelse] => { $ crate :: SyntaxKind :: ORELSE_KW } ; [otherwise] => { $ crate :: SyntaxKind :: OTHERWISE_KW } ; [predicates] => { $ crate :: SyntaxKind :: PREDICATES_KW } ; [procedure] => { $ crate :: SyntaxKind :: PROCEDURE_KW } ; [properties] => { $ crate :: SyntaxKind :: PROPERTIES_KW } ; [quot] => { $ crate :: SyntaxKind :: QUOT_KW } ; [rem] => { $ crate :: SyntaxKind :: REM_KW } ; [resolve] => { $ crate :: SyntaxKind :: RESOLVE_KW } ; [single] => { $ crate :: SyntaxKind :: SINGLE_KW } ; [supports] => { $ crate :: SyntaxKind :: SUPPORTS_KW } ; [suspending] => { $ crate :: SyntaxKind :: SUSPENDING_KW } ; [then] => { $ crate :: SyntaxKind :: THEN_KW } ; [try] => { $ crate :: SyntaxKind :: TRY_KW } ; [where] => { $ crate :: SyntaxKind :: WHERE_KW } ; [i] => { $ crate :: SyntaxKind :: I_KW } ; [in] => { $ crate :: SyntaxKind :: IN_KW } ; [language] => { $ crate :: SyntaxKind :: LANGUAGE_KW } ; [o] => { $ crate :: SyntaxKind :: O_KW } ; [to] => { $ crate :: SyntaxKind :: TO_KW } ; [#bininclude] => { $ crate :: SyntaxKind :: HASHBININCLUDE } ; [#else] => { $ crate :: SyntaxKind :: HASHELSE } ; [#elseif] => { $ crate :: SyntaxKind :: HASHELSEIF } ; [#endif] => { $ crate :: SyntaxKind :: HASHENDIF } ; [#error] => { $ crate :: SyntaxKind :: HASHERROR } ; [#export] => { $ crate :: SyntaxKind :: HASHEXPORT } ; [#externally] => { $ crate :: SyntaxKind :: HASHEXTERNALLY } ; [#from] => { $ crate :: SyntaxKind :: HASHFROM } ; [#if] => { $ crate :: SyntaxKind :: HASHIF } ; [#include] => { $ crate :: SyntaxKind :: HASHINCLUDE } ; [#message] => { $ crate :: SyntaxKind :: HASHMESSAGE } ; [#options] => { $ crate :: SyntaxKind :: HASHOPTIONS } ; [#orrequires] => { $ crate :: SyntaxKind :: HASHORREQUIRES } ; [#requires] => { $ crate :: SyntaxKind :: HASHREQUIRES } ; [#stringinclude] => { $ crate :: SyntaxKind :: HASHSTRINGINCLUDE } ; [#then] => { $ crate :: SyntaxKind :: HASHTHEN } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; [var] => { $ crate :: SyntaxKind :: VAR } ; [string] => { $ crate :: SyntaxKind :: STRING } ; [int_number] => { $ crate :: SyntaxKind :: INT_NUMBER } ; [float_number] => { $ crate :: SyntaxKind :: FLOAT_NUMBER } ; }
impl ::core::marker::Copy for SyntaxKind {}
impl ::core::clone::Clone for SyntaxKind {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for SyntaxKind {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        (*self as u16) == (*other as u16)
    }
}
impl ::core::cmp::Eq for SyntaxKind {}
impl ::core::cmp::PartialOrd for SyntaxKind {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering> {
        Some(self.cmp(other))
    }
}
impl ::core::cmp::Ord for SyntaxKind {
    #[inline]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        (*self as u16).cmp(&(*other as u16))
    }
}
impl ::core::hash::Hash for SyntaxKind {
    fn hash<H: ::core::hash::Hasher>(&self, state: &mut H) {
        ::core::mem::discriminant(self).hash(state);
    }
}
